## ゲーム制作講座
***
01_基本構造 で記したinputUpdateにあたる部分について紹介する。  
入力情報を取得する例としてキーボードからの入力情報を管理するクラスを作成する。  
DxLibのGetHitKeyStateAll関数を利用する。  

# GetHitKeyStateAll

GetHitKeyStateAll関数はキー入力情報を一括して取得できる関数だ。  
この関数はchar型の256個の配列の先頭ポインタを引数に渡すと、すべてのキー入力情報がそこに格納されて返ってくる。   

```cpp
char buf[256];
GetHitKeyStateAll(buf);
```

# KeyManagerクラス

キー入力情報を管理するKeyManagerクラスを作ってみよう。  

まずメンバとして必要なものを考える。  

基本的にゲームの中ではそのキーが何フレーム押されていたかという情報と、そのキーが離された次のフレームの情報があれば十分である。  

フレーム数を保存する変数は必要だろう。  
この型は何にしようか。  
必要な値は整数なのでint型が候補に挙げられる。  
仮にint型だとまずい点が出てきたとしよう。  
その時考えられるのはオーバーフローくらいだろう。  
int型のオーバーフローは定義されていないのでどんな挙動をするかわからない。  
int型は正の方向にだいたい21億の範囲をもっている。  
これから概算するとだいたい24日間キーを押し続けていることになる。  
この場合を考慮するかしないかで型選択が変わってくる。  
大抵の場合、3週間以上もゲームを起動したままキーを押し続けることなどありえないのでint型で十分だろう。  
unsigned型ならオーバーフローが定義されているのでその方がいいと思うかもしれないが、実はこのあと使う上での便宜上負の値を入れることがある。  
そのため今回はint型を用いる。  
もし気にする人がいるなら自分で解決策を考えてみるといいだろう。  

この様な過程を経てようやく型がintに決まった。  
一つ一つの変数に対してどの型が適正かを考えることは重要である。  

次にアクセス修飾子を決めよう。  
この値を変更するのはいつだろうか。  
それは各フレームの最初に一回更新するタイミングのみである。  
このクラス内に更新する関数を作ってしまえばprivateで十分である。  
しかし、その値は外部から必要である。  
外部から値の取得はできて変更はクラス内からのみにするのが適当である。  
その方法はいくつかあるが、関数を利用するのが簡単だろう。(C++の補完/01_アクセス修飾子 参照)  

今回は配列の中身を見たいので[]演算子を利用した方法を用いる。(C++の補完/02_演算子オーバーロード 参照)  

長々と説明してきたが、今決まったのがそのキーが押されているフレーム数を保存する変数をprivateなint型の配列で用意し、operator[]で値の取得を行えるようにするということと、それらの更新を行うメンバ関数updateを用意するということである。  

具体的にコードにしてみよう。  

キー入力の管理を行うKeyManagerクラスを用意する。  

```cpp
class KeyManager {

};
```

ここに先ほど列挙したメンバを追加していく。  

```cpp
class KeyManager {
private:
    int mKeyState[256];
public:
    void update() {
        char buf[256];
        GetHitKeyStateAll(buf);

        for(int i = 0; i < 256; i++) {
            if (buf[i]) {
                mKeyState[i]++;
            }
            else {
                mKeyState[i] = 0;
            }
        }
    }

    const int &operator[](int keyInput) {
        return (mKeyState[keyInput]);
    }
};
```

これでだいたいはできた。  

しかし、一つ問題があることに気が付いただろうか。  
mKeyStateの初期値である。  
1フレーム目で必ずGetHitKeyStateAllがbufにfalseを入れてくれるならインクリメントが呼ばれる前に0が代入されるため問題はないが、その保証はどこにもない。  

そのため、コンストラクタを定義してその中ですべての要素を0に初期化する必要がある。  

```cpp
KeyManager() {
    for(int i = 0; i < 256; i++) {
        mKeyState[i] = 0;
    }
}
```

# キー入力が終わったフレーム

ボタンを離した時に何か処理をしたい時がしばしばある。  
その処理が必要になった場面で記述するよりはKeyManagerクラスの中に閉じ込めてしまうのが適当だろう。  
もちろんそんな処理を絶対に行わないと断言できるゲームにおいては必要ないかもしれないが大した処理じゃないので実装しておいてもいいだろう。  
  
離れたフレームでmKeyStateを-1にするという処理を行う。  
update関数の中のfor文を
```cpp
for(int i = 0; i < 256; i++) {
    if(buf[i]) {
        mKeyState[i]++;
        if(mKeyState[i] == 0) mKeyState[i]++;
    }
    else {
        if(mKeyState[i] > 0) mKeyState[i] = -1;
        else mKeyState[i] = 0;
    }
}
```
に変更することで解決できる。  

buf[i]の中身がfalseだった時、mKeyState[i]の中身を確認して前のフレームでキーが押されていたか(mKeyState[i]が0よりも大きいか)を調べて代入するものを0か-1か判断している。  
buf[i]の中身がtrueだった時、これまでどおりmKeyState[i]++を実行するが、もしかしたら前のフレームでは-1だったかもしれない。  
そのときmKeyState[i]の中身は0になってしまいキーが押されていない時と見分けがつかなくなってしまう。  
そのため、mKeyState[i]が前のフレームで-1だった時(++した後に0だった時)もう一度++するという処理を追加した。  

こうしてキー入力が終わったかどうかも判断ができるようになった。  

# インスタンスの生成

クラスを作ってもインスタンスを生成しないと何も処理を行えない。(静的なメンバを除く)  
キー入力はプログラム開始から終了まで常に必要であるため、グローバル変数にしてしまっていいだろう。  

```cpp
class KeyManager;
KeyManager gKey;
```

グローバル変数の名前の頭にはgをつけるというルールを導入した。  
privateメンバにmをつけるのと同様の理由である。(C++の補完/01_アクセス修飾子 参照)

01_基本構造のinputUpdate()にあたる部分が
```cpp
gKey.update();
```
に置き換えることができる。  

# まとめ

今回はキー入力を管理するクラスの作成を行った。  
入力情報はキー入力以外にもマウスやジョイパッドなどゲームによって必要なものが違うのでこれを参考にクラスを作ってみるといいだろう。  
インスタンスの生成の時にシングルトンという単語が頭をよぎった人もいるかもしれないが、おまけで扱うのでぜひそちらも目を通してもらいたい。  
今回update関数はpublicにしてしまったが、これを呼ぶのは1フレームに1回のみなので間違って呼んでしまうことがないように工夫したい。  
これに関してはfriendを使って後ほど解決する。  
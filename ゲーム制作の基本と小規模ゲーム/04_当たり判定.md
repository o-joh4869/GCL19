## ゲーム制作講座
***
前回の続きとして当たり判定の作り方の一例を紹介する。  

# 当たり判定

シューティングゲームにおいて当然必要になってくる要素にあたり判定がある。  
これを表現しよう。  

まずどういった仕様にするかを考える。  
今まだ自機と敵機しかいないので自機と敵機が少しでも重なったとき自機のHPが減り、その敵が消滅するといったものが自然だろう。  

これを表現するためにまずPlayerクラスにHPを表すメンバ変数を追加する。  
ここで再び登場するのが型の問題である。  
今回はわかりやすく1回あたると1だけ減る整数値とする。  
ここで考えられるのがint型とunsigned型である。  
回数でカウントする限り21億などという莫大な数は扱うことがなさそうな一方で負の数は実装のどこかで使用しそうだ。  
よってint型を採用する。  
アクセス修飾子は前で紹介したようにデバッグのしやすさを考慮して、publicにする必要性がどうしても出てきてしまうまではprivateにして進める。  

Playerクラスに
```cpp
int mHP;
```
を追加し、とりあえずイニシャライザで3に初期化しておく。  

次にどうやって判定するかを考える。  
今、自機も敵機も円なので判定自体は円の中心どうしの距離が半径の和より大きいかを判定すれば良さそうだ。  

その処理はどのクラスのメンバ関数にしようか。  
もしくはC言語的な関数にしてしまう手もある。  
ここで考えるべきなのは判定前後でどの変数の値を変更するかだ。  
privateメンバ変数の値を変更するにはそのクラスのメンバ関数であることが必要なので、変更するprivateメンバが一つだった場合必然的にそのクラスのメンバにすることが決まる。  
仕様をもう一度確認すると、自機と敵機があたったと判定されたら自機のHPを減らしあたった敵を消滅させる。  
つまり、変更するのはPlayerのprivateメンバであるmHPとEnemyManagerのprivateメンバのmEnemyである。  
困ったことに異なるクラスのprivateメンバを変更する必要が出てきてしまった。  
こういうとき、早々あきらめてどちらかをpublicにしてしまうのはもったいない。  
mHPを例にとると、1減らすという処理しかしないのにpublicにしてしまったら10増やすことも0にすることもできてしまうからだ。  
そこでupdate関数以外にメンバ関数を変更する関数を追加する必要がある。  
PlayerとEnemyManagerのどちらにメンバを変更する関数を追加するかを考える。  
実際のところどちらに追加しても当たり判定は実現できそうである。  
このとき考えるのは計算量である。  
EnemyManagerのupdateの中では敵のクラス一個一個を回ってupdate関数を実行するループが存在している。  
ループにかかる計算量は結構多いためできれば避けたい。  
今Playerクラスの中で当たり判定を行うと、mEnemyの中を一つ一つ回るループが発生してしまう。  
一方EnemyManagerのupdate関数の中にはすでにループが存在しているため、その中でついでに当たり判定まで行ってしまえばループを増やすことはない。  
よって今回はEnemyManagerのupdate関数のループの中で処理を行うようにする。  

ループの中はどう記述しようか。  
敵の種類によって自機の大きさや形などが違うことが多いため処理の書き方も必然的に変わってくる。  
種類によって処理を変えるというのはポリモーフィズムの得意なところなのでEnemyクラスにvirtualを付けてjudge関数を追加しよう。  
これに必要なものを渡して処理を行う。  

関数を作るのに必要な要素は返り値と引数である。  
追加するjudge関数のこれら二つをどうするか考える。  
今回judge関数はEnemyクラスに作りEnemyManagerから呼び出すが、あたったあとEnemyManager::mEnemyからあたったものを削除しなければならない。  
これはEnemyクラスからは行えないので何とかして自分自身を削除するようにEnemyManagerに伝えなくてはならない。  
これを実現するために自分自身を削除するかどうかをbool型で返すことにする。  
引数について考えよう。  
引数として通常渡すものは関数の処理を記述するのに必要なものである。  
今回必要なものはPlayerクラスのmPosとmHPを1減らす関数、円の大きさである。  
メンバ関数を渡すのは面倒が多く、引数が複雑になりそうなのでここではPlayerクラスの参照を直接渡してしまうことにする。  
必要ない部分まで見えてしまうことが気になる人は自分でどうするべきか考えてみるといいだろう。  

mEnemyの関数に渡すにはEnemyManagerを介する必要があり、今までEnemyManagerにはPlayerのgetPosを参照するように引数が設定されていたが、Playerのインスタンスを直接もらってくるように変更するのでこれを削除し設定しなおす。  
ここで一つルールを設ける。  
仮引数に参照を指定した場合、中身を変更する可能性があるときは基本的に参照ではなくポインタをもらってくるというものだ。  
こうする理由として、関数を使う側から見たとき実引数に渡したものが変更されるかわからないからである。  
ポインタを指定すれば見た目で一瞬で判断できる。  

ここまでのことをコードにしていこう。  
ついさっきはPlayerの参照をもらってくるとしたが、Playerのポインタ型をもらってくることにする。  
Enemy::update関数は変更しないのでEnemyManager::updateの中からはplayer->getPos()を実引数に指定する。  
judge関数の呼び出しはEnemyManager::updateのループ内で行う。  
mEnemyの要素を削除するのにrange-based-forを用いていると要素の検索に計算量がかかってしまうのでやや面倒だがイテレータでループを回すように変更する。  
```cpp
void EnemyManager::update(Player *player) {
    //...
    
	for (auto itr = mEnemy.begin(); itr != mEnemy.end();) {
        (*itr)->update(player->getPos());
        if ((*itr)->judge(player)) {
            itr = mEnemy.erase(itr);
        }
        else itr++;
	}
}
```

実はalgorithmヘッダーにあるstd::remove_if関数を使って
```cpp
void EnemyManager::update(Player *player) {
    //...
    
	std::remove_if(mEnemy.begin(), mEnemy.end(), 
        [&player](std::unique_ptr<Enemy> &i){
            i->update(player);
            return (i->judge(player));
        }
    )
}
```
とすることもできる。  
実はこうした方が上の例より高速なのだが、とりあえずはわかりやすいイテレータを用いた方法を採用しておく。  

さて次にEnemyとEnemyAにjudge関数を追加する。  
返り値はvoid、引数にはplayerのポインタ型を指定する。  
```cpp
bool Enemy::judge(Player *player) const {

}
bool EnemyA::judge(Player *player) const {

}
```

こうしてようやく具体的な処理を書く場所を作ることができた。  
よろこんでEnemy::judge関数の中身を書こうとするとまだいくつか壁が残っている。  
PlayerとEnemyの円の大きさが必要なのだ。    
いまは適当にDrawCircle関数に直接書いてしまっているが本当はよくない。  
自機の大きさを少し変えたくなることだってあるし、今後アイテムなどを実現していったときに動的に大きさを変更していくことだって十分に考えられる。  
コードが大きくなる前にさっさとPlayerクラスとEnemyクラスのメンバに入れてしまおう。  
DrawCircleの引数がint型なので型はint型でもいいが、mPosの要素がfloat型であるためにjudge関数の中で型が違うために警告がでてしまうことが考えられる。  
いちいちキャストするのも面倒なのでここはmPosに合わせてfloat型にしよう。  

Playerにprivateで、Enemyにprotectedで
```cpp
float mRadius;
```
を追加する。  
今は特に変更しないのでイニシャライザで今の値に初期化しておく。  
EnemyAで大きさを変えたい場合は派生クラス専用に半径を指定できるコンストラクタをprotectedで作っておくといいかもしれない。  
今回Enemyの中からPlayerの半径の大きさ情報が欲しいので値を返す関数も作っておく。  
```cpp
const auto &getRadius() {
    return mRadius;
}
```

こうしてEnemy::judge()の中身が書けるようになっただろう。  
最初にも紹介したが中心間の距離と半径の和を比べるということをする。  
```cpp
bool Enemy::judge(Player *player) {
    bool flag = (mPos - player->getPos()).length() < (mRadius + player->getRadius);
    if (flag) player->decHP();
    return flag;
}
```

コードを見て思った人もいるかもしれないがPlayerクラスにHPを減らす関数をまだ作っていなかった。  
今回はdecHPという関数を作成してHPを減らす処理をした。  

今、HPがいくつであるかを表示していないので現段階で実行してもわからない。  
そこで試験的にScreenFlip関数の手前でDrawFormatString関数を使って表示してみよう。  

最初はHPが3から始まり、敵にあたるとHPが減って敵が消えたら成功だ。  

# まとめ

今回は当たり判定の扱い方の一例を紹介した。  
まだまだ改善の余地はあるのでぜひ考えてみてほしい。  
ここまでやってきて気づいた人も多いだろうが、ゲーム制作では実現させたいことの具体的な処理を考えることよりも、ある程度の拡張性を持たせながらできる限りミスしたときにカバーしやすいようにかつ高速に動作するようにクラスや関数を設計していくことの方が実は重要で大変なのである。  
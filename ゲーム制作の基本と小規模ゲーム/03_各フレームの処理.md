## ゲーム制作講座
***
01_基本構造 で記したupdateおよびdrawにあたる部分について紹介する。  
簡単なシューティングゲームを例に組み立て方を学ぶ。  
描画関連は各クラスのdraw関数に閉じ込めるが、DxLibのDrawCircle命令を用いる。  
前回作成したKeyManagerとツールのVector2を用いるのでヘッダーファイルを用意してインクルードするかこのコードの頭にコピペしておいてほしい。  
ファイル分けは後でやるのでよくわからない人はおとなしくコピペしよう。  

# Playerクラス

まずは自分を動かすところからはじめよう。  

自機を実装するのに必要なものは何だろうか。  

まず、座標情報は必要だろう。  
その型は何がいいだろう。  
int型でもいいが、斜め移動したときにsqrt(2)の掛け算があることを考えると少し浮動小数点の方がいいかもしれない。  
もちろんint型にして斜め移動はsqrt(2)倍だけ早く進んでしまう仕様にしてもいい。  
後述するが、int型の方が圧倒的に当たり判定を作りやすい。  
今回ははじめにでも話したC++講座の続編として話をしているので少し複雑だがより自然な挙動を表現できるfloat型で話を進める。  

移動手段はどうしようか。  
とりあえずはキーで移動すればいいだろう。  

とりあえずの実装を書くためには関数に処理を書いてそれを呼び出す形にするといいだろう。  
必要なパラメータとその処理をまとめるためにはクラスを用いるのが便利である。  

描画するための関数も必要だろう。  
とりあえず今回は円を書いておくが実際は画像を用いたい場合がほとんどである。  
画像の準備ができたときにその処理を書くためのところをはっきりされておいた方が円滑にすすむ。  
画像の大きさなどが決まっているなら早めに仮の画像を用意して書いておくとファイルを差し替えるだけで済む。  

これらをふまえてクラスを作成する。  
```cpp
class Player {
public:
    Player(const Vector2<float> &pos);
private:
    Vector2 mPos;
public:
    void update();
    void draw() const;
};
```

とりあえず座標を表すmPosとupdate,draw関数をつくっておいた。  
何も言わずにmPosをprivateメンバにしてしまったがその理由はわかるだろうか。  
Playerの位置の変更はすべてupdateの中のみで行うということだ。  
基本的にクラスのメンバ変数はprivateにしておくことが多く、値の変更は関数を通じてのみ行う。  
意図しない挙動をしたときprivateにしていればメンバ関数のみを見ればいいのでデバッグがしやすい。  

メンバ関数の中身を書いていく。  
Playerの挙動の制御はキー入力で行うので前回のKeyManagerクラスを用いる。  

```cpp
Player::Player(const Vector2<float> &pos) : 
    mPos(pos)
{
}
void Player::update() {
    Vector2<float> dPos(0.0f, 0.0f);
    if(gKey[KEY_INPUT_LEFT] > 0) dPos -= Vector2<float>(1.0f, 0.0f);
    if(gKey[KEY_INPUT_UP] > 0) dPos -= Vector2<float>(0.0f, 1.0f);
    if(gKey[KEY_INPUT_RIGHT] > 0) dPos += Vector2<float>(1.0f, 0.0f);
    if(gKey[KEY_INPUT_DOWN] > 0) dPos += Vector2<float>(0.0f, 1.0f);
    mPos += dPos.getNormalized() * 5.0f;
}
void Player::draw() const {
    DrawCircle((int)mPos[0], (int)mPos[1], 20, GetColor(0, 0, 255));
}
```

中身に関してはとりあえずインスタンスを生成した場所に自機を置くことができてupdate関数を呼ぶことで移動でき、draw関数で描画するということだけわかってもらえれば大丈夫だ。  

# インスタンスの生成

今回はとりあえずの処理を書いていくのでメインループの前にインスタンスを生成すれば大丈夫だろう。  
初期の位置は自由に決めてもらって構わないが資料の中では(0,0)とする。  

```cpp
Player player(Vector2<float>(0.0f, 0.0f));
```

生成したインスタンスからメインループ内で関数を呼び出す。  

```cpp
while (ProcessMessage() == 0) {
	ClearDrawScreen();
    gKey.update();

    player.update();
    player.draw();

	ScreenFlip();
}
```

実行してみると十字キーで青い丸を動かすことができるだろう。  
これで第一段階は終了である。  

# Enemyクラス

Playerクラスと同様にして敵の挙動を管理するEnemyクラスを作ってみよう。  
```cpp
class Enemy {
public:
    Enemy(const Vector2<float> &pos);
private:
    mPos;
public:
    void update();
    void draw() const;
};
```

クラスの定義はPlayerクラスとほとんど変わらない。  

次に各メンバ関数の定義を書いていく。  
ひとまずは赤い円が下に動くだけの実装だ。  
```cpp
Enemy::Enemy(const Vector2<float> &pos) : 
    mPos(pos)
{}

void Enemy::update() {
    mPos += Vector2<float>(0.0f, 1.0f)
}

void Enemy::draw() const {
    DrawCircle((int)mPos[0], (int)mPos[1], 15, GetColor(255, 0, 0));
}
```

# インスタンスの生成

とりあえずPlayerと同様にメインループの前でインスタンスを生成する。  

```cpp
Enemy enemy(Vector2<float>(50.0f,20.0f));
```

メインループでメンバ関数を呼び出す。  

```cpp
while (ProcessMessage() == 0) {
	ClearDrawScreen();
    gKey.update();

    player.update();
    enemy.update();
    player.draw();
    enemy.draw();

	ScreenFlip();
}
```

ここまでを実行すると自分で動かせる青い丸と下に落ちていく赤い丸が描画される。  
このように、複数のものを動かしたいときは1フレームの中でいくつも値を変更して描画する。  

# EnemyManagerクラス

今のままでは敵は1つのままである。  
敵を増やすにはEnemyのインスタンスを増やせばいいが、メインループの中で
```cpp
enemy1.update();
enemy2.update();
//...
```
とするのは全体が見えにくくなり関数の呼び出し忘れも起こりうる。  
配列でEnemyクラスのインスタンスを管理し、for文でメンバ関数を呼び出すことで解決できる。  
メインループに直接ループを書いてもいいが、全体が見にくくなってしまう上、後に数を動的に変更するときにも面倒が多い。  
EnemyManagerクラスを作成しそのクラスを介してEnemyクラスのインスタンスを管理する。  

ここではstd::arrayを用いるのでarrayヘッダーをインクルードしておいてほしい。  
```cpp
#include<array>
```

まずクラスを定義する。  
```cpp
class EnemyManager {
public:
    EnemyManager();
private:
    sta::array<Enemy, 3> mEnemy;
public:
    void update();
    void draw() const;
};
```

次にメンバ関数を定義する。  
```cpp
EnemyManager::EnemyManager() {
    mEnemy[0] = Enemy(Vector2<float>(100.0f, 20.0f));
    mEnemy[1] = Enemy(Vector2<float>(200.0f, 50.0f));
    mEnemy[2] = Enemy(Vector2<float>(300.0f, 30.0f));
}

void EnemyManager::update() {
    for(auto &i : mEnemy) {
        i.update();
    }
}

void EnemyManager::draw() const {
    for(const auto &i : mEnemy) {
        i.draw();
    }
}
```

インスタンスの生成はこれまでどおりメインループ前で行い、メインループ内でそのメンバ関数を呼び出す。  
このとき、前のEnemyクラスのインスタンスを作らないように変更する。  

```cpp
Player player(Vector2<float>(0.0f, 0.0f));
EnemyManager enemyManager;

while (ProcessMessage() == 0) {
	ClearDrawScreen();
    gKey.update();

    player.update();
    enemyManager.update();
    player.draw();
    enemyManager.draw();

	ScreenFlip();
}
```

こうすることで敵を複数に増やすことができた。  
数を変更したいときはメインループを直接いじることなくEnemyManagerを変更すればいいので全体が見やすい。  

# 敵の数を自由に変更する

今のままでは敵は増えたり減ったりせず、ずっと3体のままである。  
実際にゲームを作るためにはゲーム内で自由に敵の数を変更できる必要がある。  

これを実現するためにstd::vectorを用いる。  
vectorヘッダーをインクルードしてほしい。  
また、今回はもうstd::arrayを使用しないのでインクルードしている行を消してしまって構わない。  
```cpp
#include<vector>
```
EnemyManagerを次のように変更する。  

```cpp
class EnemyManager {
public:
    EnemyManager();
private:
    sta::vector<Enemy> mEnemy;
public:
    void update();
    void draw() const;
};
```

次にコンストラクタの定義を変更する。  

```cpp
EnemyManager::EnemyManager() {
    mEnemy.emplace_back(Enemy(Vector2<float>(100.0f, 20.0f)));
    mEnemy.emplace_back(Enemy(Vector2<float>(200.0f, 50.0f)));
    mEnemy.emplace_back(Enemy(Vector2<float>(300.0f, 30.0f)));
}
```

vectorを用いて表すことができたので自由に敵の数を変更できる。  

zキーで敵を増やし、xキーで敵を消すという実装をEnemyManager::updateに実装しよう。  
敵を消すのは乱数を取得して適当なものを選んでもいいが、ひとまず最初の要素を削除する。  

```cpp
void EnemyManager::update() {
    if(gKey[KEY_INPUT_Z] == 1) mEnemy.emplace_back(Enemy(Vector2<float>(150.0f, 0.0f)));
    if(gKey[KEY_INPUT_X] == 1) mEnemy.erase(mEnemy.begin());

    for(auto &i : mEnemy) {
        i.update();
    }
}
```


こうして、ゲーム内で自由に敵の数を変更することができた。  

# 敵の種類を増やす

今まで敵は1種類しかいなかった。  
しかし敵の種類を増やしたいことは多々ある。  
これをpublic継承によるポリモーフィズムで表現する。  

前準備としてmEnemyの型をEnemyのポインタ型に変更する。  
```cpp
std::vector<Enemy*> mEnemy;
```

これに伴ってメンバ関数を変更する。  

```cpp
void EnemyManager::update() {
    for(auto &i : mEnemy) {
        i->update(); //iはEnemy*型なのでアロー演算子を用いる
    }
}

void EnemyManager::draw() const {
    for(const auto &i : mEnemy) {
        i->draw(); //updateと同様
    }
}
```

mEnemyに持たせるものはEnemy型のインスタンスを指すポインタである必要があるためnew演算子を用いる。  

```cpp
EnemyManager::EnemyManager() {
    mEnemy.emplace_back(new(Enemy(Vector2<float>(100.0f, 20.0f))));
    mEnemy.emplace_back(new(Enemy(Vector2<float>(200.0f, 50.0f))));
    mEnemy.emplace_back(new(Enemy(Vector2<float>(300.0f, 30.0f))));
}
```

newしたものはdeleteしないといけない。  
これをEnemyManager::updateに適応する。  

```cpp
void EnemyManager::update() {
    if(gKey[KEY_INPUT_Z] == 1) mEnemy.emplace_back(new (Enemy(Vector2<float>(150.0f, 0.0f))));
    if(gKey[KEY_INPUT_X] == 1) {
        delete mEnemy[0];
        mEnemy.erase(mEnemy.begin());
    }

    for(auto &i : mEnemy) {
        i->update();
    }
}
```

こうすることでとりあえずさっきのものと同じことをポインタを介して行うことができた。  
(実はdeleteできていない部分があるが、後でスマートポインタを用いた方法で書き直すので今回はスルー)  

ポインタを使ってインスタンスを管理できたのでpublic継承を用いて敵の種類を増やしていこう。  

まず、Enemyクラスのメンバ関数とデストラクタを仮想関数化する。  
```cpp
class Enemy {
public:
    Enemy(const Vector2<float> &pos);
private:
    mPos;
public:
    virtual void update();
    virtual void draw() const;
    virtual ~Enemy() = default;
};
```

これを継承してEnemyAを作る。  

```cpp
class EnemyA : public Enemy {
public:
    EnemyA(const Vector2<float> &pos);
    void update() override;
    void draw() const override;
}
```

Enemy::mPosにEnemyAからもアクセスしたいのでEnemy::mPosをprivateからprotectedに変更しておく。  

とりあえずEnemyAは右に移動していくものとする。  
また、差別化のため緑色にする。  

```cpp
EnemyA::EnemyA(const Vector2<float> &pos) : 
    Enemy(pos)
{}

void EnemyA::update() {
    pos += Vector2<float>(1.0f, 0.0f);
}

void EnemyA::draw() const {
    DrawCircle((int)mPos[0], (int)mPos[1], 15, GetColor(0, 255, 0));
}
```

あとはEnemyManagerの中でnewしてmEnemyに追加していくだけである。  

とりあえずCキーでvectorに追加していくことにする。  

```cpp
void EnemyManager::update() {
    if(gKey[KEY_INPUT_Z] == 1) mEnemy.emplace_back(new (Enemy(Vector2<float>(150.0f, 0.0f))));
    if(gKey[KEY_INPUT_X] == 1) {
        delete mEnemy[0];
        mEnemy.erase(mEnemy.begin());
    }
    if(gKey[KEY_INPUT_C] == 1) mEnemy.emplace_back(new (EnemyA(Vector2<float>(0.0f, 150.0f))));

    for(auto &i : mEnemy) {
        i->update();
    }
}
```

# unique_ptrを用いたポリモーフィズム

ポインタを用いてポリモーフィズムを表現したが、deleteし忘れが起こる可能性があるのでスマートポインタを用いた形式に書き直す。  

unique_ptrを用いるためにmemoryヘッダーをインクルードする。  
```cpp
#include<memory>
```

まず、EnemyManagerクラスを変更する。  

```cpp
class EnemyManager {
public:
    EnemyManager();
private:
    sta::vector<std::unique_ptr<Enemy>> mEnemy;
public:
    void update();
    void draw() const;
};
```

次に、newしているところをstd::make_unique<Enemy>に置き換える。  

```cpp
EnemyManager::EnemyManager() {
    mEnemy.emplace_back(std::make_unique<Enemy>(Vector2<float>(100.0f, 20.0f)));
    mEnemy.emplace_back(std::make_unique<Enemy>(Vector2<float>(200.0f, 50.0f)));
    mEnemy.emplace_back(std::make_unique<Enemy>(Vector2<float>(300.0f, 30.0f)));
}

void EnemyManager::update() {
    if(gKey[KEY_INPUT_Z] == 1) mEnemy.emplace_back(std::make_unique<Enemy>(Vector2<float>(150.0f, 0.0f)));
    if(gKey[KEY_INPUT_X] == 1) mEnemy.erase(mEnemy.begin());
    if(gKey[KEY_INPUT_C] == 1) mEnemy.emplace_back(std::make_unique<EnemyA>(Vector2<float>(0.0f, 150.0f)));

    for(auto &i : mEnemy) {
        i->update();
    }
}
```

これでunique_ptrを用いた形に変更ができた。  

# 自機を追跡する敵機

これまで敵機は一定の動作を続けるだけだった。  
こんなシューティングゲームはそうそうないわけで、もう少しましな動作をさせたい。  
そこで自機を追跡させてみることにする。  

自機を追跡させるには自機の位置情報が必要である。  

方法としてはいくつかあると思う。  
Enemy::updateの引数として渡すという方法が思い浮かびやすい。  
しかしすべての敵のupdate関数はオーバーライドしているために引数まで一致している必要がある。  
それを考えるとすべての敵に必要とは限らないものを引数に指定するのは少し微妙な感じがする。  

別の方法としてVector2のconst参照型を必要な敵クラスのメンバに持たせ、コンストラクタでPlayerの位置を渡す方法だ。  
これならば自機を追跡するものだけに指定できるし、問題ないように思える。  
この方法の欠点としては追跡するターゲットを途中で変更できない点だ。  
最初は自機を追跡するだけでも問題ないが、将来的には敵がアイテムを奪ったり自機が身代わりを投げてしばらく追跡から逃れたりといった機能を付けたくなる可能性が十分に考えられる。  
そのときに追跡するターゲットを変更できないというのは致命的である。  
もちろんそんなことを絶対にしなかったり、ターゲットが常に自機に向くことが特徴の敵なら上の方法でやってもらって構わない。  
しかし多少の拡張性は考えながらコードを組みたい。  
Vector2のポインタを保存するという方法もなくはないが、ポインタの先にあるものがvectorなどで管理されていた場合メモリ再確保で移動してしまう恐れがあったりいつの間にか解放されていたりと生のポインタを扱うのには面倒なことが付きまとう。  

一番確かな方法はPlayerやEnemy、今後追加するかもしれないアイテムなど、動きを決定するために必要な要素を管理するクラスすべてを共通のクラスを基底にして作成し、その基底クラスに自分自身が何であるかのIDを保存するメンバをもたせ、そのポインタの配列などをupdate関数の引数に設定して必要なタイミングで標的を検索できればいい。  
自分自身が何であるかを調べるのにtypeid演算子を利用してみてもいいかもしれない。  

今回はそこまでするつもりはないのでおとなしくPlayerのVector2をupdate関数に直に渡すことにする。  
実際十分小規模なうちはこれで十分である。  

Enemyのupdate関数に渡すためにはEnemyManagerのupdate関数にも渡す必要がある。  
EnemyManagerとEnemyとEnemyAのすべてのupdate関数の引数に
```cpp
const Vector2<float> &playerPos  
```
を追加する。  
Playerクラスにも
```cpp
const auto &Player::getPos() {
    return mPos;
}
```
を追加する。  
メインループでは
```cpp
enemyManager.update(player.getPos());
```
とし、EnemyManager::update内でもmEnemy->updateにplayerPosを渡す。  
```cpp
void EnemyManager::update(const Vector2<float> &playerPos) {
    //...
    for(auto &i : mEnemy) {
        mEnemy->update(playerPos);
    }
}
```
こうしてEnemy::updateでplayerPosを得ることができた。  
今回、Enemyの方は挙動を変えずにEnemyAの方で追跡するようにする。  
```cpp
void Enemy::update(const Vector2<float> &playerPos) {
    mPos += Vector2<float>(0.0f, 1.0f); //変更なし
}
```

```cpp
void EnemyA::update(const Vector2<float> &playerPos) {
    mPos += (playerPos - mPos).getNormalized(); //自分からみたplayerの方向に長さ1だけ移動する
}
```

こうして追跡させることができた。  

# まとめ

簡易的なシューティングゲームの自機と敵機を作ってコードのまとめ方を紹介した。  
クラスを使う場面やメンバの型などをどのように決定していくかを丁寧に説明した。  
次回これに当たり判定を付けていく。  
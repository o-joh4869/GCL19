## ゲーム制作講座
***
コードが複雑になりがちなところがシーン遷移である。  
この資料ではクラスを用いたシーン遷移の方法を紹介する。  

# switch文を利用したシーン遷移

いきなりクラスでやるのも無理があるので比較的理解が簡単なswitch文を利用したシーン遷移を先に紹介する。  

まず、メインループを

```cpp
while(ProcessMessage() == 0) {
    ClearDrawScreen();
    gKey.update();
    //
    ScreenFlip();
}
```

とする。  

ここで、//の場所に具体的な処理を書いていく。  
while文の前にint型の今のシーンを表す変数gamemodeを宣言しておき、それに応じてswitch文を利用する。  
```cpp
int gamemode = 0;

while(ProcessMessage() == 0) {
    ClearDrawScreen();
    gKey.update();
    switch(gamemode){
    case 0:
        //0のときの処理
        break;
    //別のシーンは追加
    }
    ScreenFlip();
}
```

こうすることでとりあえずシーン遷移はできた。  

列挙体を利用すると少しミスを減らしやすい形にできる。

```cpp
enum GameMode {
    GAMEMODE_TITLE,
    GAMEMODE_GAME
};
```

と定義しておくことで

```cpp

GameMode gamemode = GAMEMODE_TITLE;

while(ProcessMessage() == 0) {
    ClearDrawScreen();
    gKey.update();
    switch(gamemode) {
    case GAMEMODE_TITLE:
        //0のときの処理
        break;
    //別のシーンはここに追加
    }
    ScreenFlip();
}
```

とできる。  
次のシーンに移動させたいとき、具体的な整数で管理するよりもミスが減る。  
間にシーンを挿入したい時を考えれば容易に理解できるだろう。  

# クラスを利用したシーン遷移

switch文を利用して分岐していたところをpublic継承によるポリモーフィズムを利用して処理をスッキリさせる。  

```cpp
class SceneBase {
protected:
    SceneBase() {}
public:
    virtual ~SceneBase() = default;
    virtual void update() {};
};
```

というクラスを用意しておく。  
今後これを継承して各シーンクラスを作成していく。  

メインループはできるだけスッキリさせたいのでシーンを管理するSceneManagerクラスを作成する。  

```cpp
class SceneManager {
public:
    SceneManager();
    void update();
private:
    enum GameMode {
        GAMEMODE_TITLE,
        GAMEMODE_GAME,
        GAMEMODE_SIZE
    };
    std::array<std::unique_ptr<SceneBase>, GAMEMODE_SIZE> mScene;
    GameMode mGameMode;
};

SceneManager::SceneManager() : 
    mGameMode(GAMEMODE_TITLE)
{
    mScene[GAMEMODE_TITLE] = new Title();
    mScene[GAMEMODE_GAME] = new Game();
}
```

こうすることでメインループは

```cpp
SceneManager sceneManager;
while(ProcessMessage() == 0) {
    ClearDrawScreen();
    keyupdate();
    
    sceneManager->update();

    ScreenFlip();
}
```

となる。  

今のままではシーンが切り替わらない。  
SceneManagerクラスにchangeScene関数を追加して引数に次のシーンのGameModeを指定することで遷移を実現する。  

```cpp
class SceneManager {
public:
    SceneManager();
    enum GameMode {
        GAMEMODE_TITLE,
        GAMEMODE_GAME,

        GAMEMODE_SIZE
    };
    void changeScene(const GameMode &next);
    void update();
private:
    std::array<std::unique_ptr<SceneBase>, static_cast<size_t>(GAMEMODE_SIZE)> mScene;
    GameMode mGameMode;
};

void SceneManager::update() {
    mScene[mGameMode]->update();
}
```

とすることで一応はシーン遷移ができた。  

# 問題点

この方法だと値の共有ができない。  
メンバに参照型を持たせてコンストラクタで前のシーンのポインタをもらってきて初期化すればできなくはない。  
あとはグローバル変数にしてしまうという方法もあるだろう。  
いずれにせよ何かしら方法を考えなくてはいけない。  

さらに、今回最初にすべてのクラスのインスタンスを生成してしまって終了まで解放も生成もしてないのでコンストラクタが呼ばれるのは一度きりである。  
ゲームが終わって一度タイトル画面などに戻って再度ゲーム画面に行ったときに元の値に戻っていなければゲームとして成立しない。  
HPが0になってゲームオーバーしてタイトルに戻ってきたのに始めたときすでにHPが0なら何もせずゲームオーバーである。  
この事態を解決するにはSceneBaseクラスにvirtualでinit関数を追加してSceneManager::changeScene関数の中で次のinit関数を呼ぶという方法がある。  
しかし元をたどればインスタンスを生成しっぱなしというところがまずかったわけで、前のものを解放して次のものを生成するという具合に変更すればこの問題は解決する。  
大規模化の方では生成したら解放してから次に行くということを徹底して行っている。  
余裕があったらここまでのヒントで自分で考えてみるといいかもしれない。  

# まとめ

一応としたのは、今後ファイル分け等を考慮していったときに少し(だいぶ)変更点があるからである。  
その時になったらまた紹介するが、1人で作る小規模なゲームにおいてはこれで十分である。  
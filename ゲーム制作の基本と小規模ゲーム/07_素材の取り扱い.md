## ゲーム制作講座
***

画像やサウンドなどの素材の扱い方について紹介する。  

# ハンドル

DxLibにおいてはハンドルというものを介して読み込んだ画像やサウンドにアクセスする。  
これはint型の変数に保存できる。  
LoadGraph関数やLoadSoundMem関数を読んだときハンドルが返ってくる。  
基本的にはメモリ上のあるところに読み込まれた素材の先頭ポインタをint型にキャストしたものが返ってくるといった感覚で問題ないと思う。  

# ファイルパス

LoadGraph関数などはファイルパスを引数に指定してファイルを読み込む。  
コードを書いていくときにフォルダ分けをしていると、ある位置に置いたファイルへのファイルパスをどう指定したらいいのかわからなくなる。  
実は指定したファイルパスはコンパイルしてexeファイルが作られてから使われるのでファイルパスを書いたcppファイルがどこにあっても関係ない。  
実際置く場所はCodeフォルダを置いた場所、つまりプロジェクトのフォルダの中からの相対参照を指定する。  
このフォルダに直接ファイル「image.bmp」を置いた場合、ファイルパスは
```cpp
LoadGraph("image.bmp");
```
もしくは
```cpp
LoadGraph("./image.bmp");
```
と指定する。  
最初フォルダを確かめる程度ならこのフォルダに直接書いてしまえば問題ないが、Codeフォルダやそれ以外のファイルがある中で画像ファイル直置きというのは少しやりたくない。  
そこでimagesフォルダを作成しその中に画像ファイルを入れることにする。  
こうしたときのパスは
```cpp
LiadGraph("./images/image.bmp");
```
となる。  

# HandleManagerクラス

小規模ゲームの定義として素材の読み込みを最初にすべて行ってしまっても問題がないものとした。  
そのため、handleをメンバに持ち画像の読み込みを行う関数で読み込むクラスを作成する。  
コンストラクタで読み込みを行わない理由は、DxLibのDxLib_Init関数よりも前に関数を呼び出してしまっても正常に動作しない可能性があるのに対してインスタンスはグローバル変数として生成したいためである。  

さて、HandleManagerクラスを実際に作っていこう。  
まず、HandleManager.hとHandleManager.cppを用意する。  
```cpp
/* HandleManager.h */
#pragma once
class HandleManager {
public:
    HandleManager();
private:
    int mHandle[100]; //素材の数を適当に100とした
public:
    void load();
    const int &operator[](const int &handleName) const {
        return mHandle[handleName];
    }
};

extern HandleManager gHandle;
```

```cpp
/* HandleManager.cpp */
#include"HandleManager.h"
#include<DxLib.h>
HandleManager::HandleManager() {
}
void HandleManager::load() {
    mHandle[0] = LoadGraph("./images/image.bmp");
    //...
}
HandleManager gHandle;
```

このとき、operator[]でハンドルにアクセスできるようにした。  
こうすることで
```cpp
gHandle[2];
```
とするだけで2に対応する素材へのハンドルが受け取れる。  

メインループの前で忘れずにload関数を呼ぼう。  
```cpp
gHandle.load();
```

# 列挙体を利用した素材へのアクセス

シーン遷移をやった回でも登場したenumを利用して素材数をコンパイラに判断してもらう。  
HandleManager.hのクラスの定義の前に
```cpp
enum HandleName {
    GRHANDLE_IMAGE,
    GRHANDLE_IMAGE2,
    //...
    HANDLE_SIZE
};
```
としておく。  
一つ素材を増やすたびにenumの中身を増やしていくのだが、必ず最後に素材に対応しないHANDLE_SIZEという要素を追加しておく。  
するとHANDLE_SIZEには上で列挙したものの数が入る。  
これをHandleManagerの中のmHandleの[]の中に入れて
```cpp
class HandleManager {
    //...
private:
    int mHandle[HANDLE_SIZE];
    //...
};
```
とすることでぴったりサイズの配列ができる。  

ついでにoperator[]の引数もHandleName型に変更して
```cpp
const int &operator[] (const HandleName &handleName) const {
    return mHandle[handleName];
}
```
とすることで配列外参照をある程度防ぐことができる。  

こうしてHandleManager.hをインクルードしたすべてのファイルで
```cpp
gHandle[GRHANDLE_IMAGE];
```
のようにすればハンドルを取得できる。  

enumで定義された型からint型への暗黙のキャストを平然と使っているが、気にする人がいたらint型やsize_t型にキャストすれば問題ないだろう。  
普通にC言語的に
```cpp
(int)GRHANDLE_IMAGE;
```
としてもいいし、static_castを使って
```cpp
static_cast<int>(GRHANDLE_IMAGE);
```
としてもいいだろう。  

# LoadDivGraph関数と列挙体

DxLibにはLoadDivGraph関数がある。  
これは大きな画像に一定間隔で書かれた画像を分割して読み込む関数である。  
この引数にはint型のポインタ型を渡し、そこから先の連続したメモリ領域に分割した画像のハンドルが次々と入れられていく。  
要件として渡したポインタ変数から先に連続したメモリ領域が必要だ。  
ほかの一枚一枚読み込んできた画像にアクセスできるmHandleで分割した画像も一括して扱う方法がある。  
その分割数だけ連続した領域があればいいので
```cpp
enum HandleName {
    GRHANDLE_IMAGE,
    //...
    GRHANDLE_DIV_INI,
    GRHANDLE_DIV_END = GRHANDLE_DIV_INI + 12 - 1, //12にあたる部分が分割数
    //...
    HANDLE_SIZE
};
```

# まとめ

今回は素材の取り扱いについてHandleManagerクラスを使って紹介した。  
この回のサンプルコードではタイトル画面に雑な画像を描画してみた。  
この方法は素材を追加したときこのヘッダーファイルをインクルードしているすべてのcppファイルでコンパイルのしなおしが発生するため、素材の追加を細かく行う場合はよくない。  
素材が必要になりそうなところをcppファイルにコメントアウトなどでメモっておき、追加するときは一気に追加するなど気休め程度の対策はあるが限界はある。  
この方法が通用しなくなるレベルになったらこの講座で言う小規模ゲームではなくなったと判断してもらって次の大規模化に進んでもらいたい。  
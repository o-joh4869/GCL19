## ゲーム制作講座
***
STLの一つであるlistについて紹介する。  
基本的にvectorで十分であるが、高速化のためには必要不可欠なものである。  

# std::list

std::listを使うにはlistをインクルードする必要がある。  
```cpp
#include<list>
```

書き方は
```cpp
std::list<int> l;
```
である。  

std::list::iteratorなども定義されており、vectorとほぼ同様に扱うことができる。  

# リスト構造

リスト構造とは、データ構造の一つである。  

一つ一つのデータが次のデータの場所もしくは前のデータの場所もしくはその両方を持っている構造である。  
次のデータの場所を持つという構造であるとき、最初のデータさえわかれば後は数珠繋ぎにすべてのデータを見ることができる。  

簡単なコードにすると、
```cpp
class data {
public:
    int a;
    int b;
    //...
    data *next;
};
```
のようになっており、次のデータが追加されたらnextにそのデータのポインタが入るという仕組みである。  

std::listでは上のものと若干の違いはあるが、std::list::iteratorを利用して各データと、前後のデータのiteratorを持っている。  
前後両方のデータの場所をもつものを双方向リスト構造という。  

# vectorとの違い

結局のところlistもvectorと同じ複数のデータを動的に保持するためのクラスである。  

vectorと大きく異なる点はいくつかある。  
listの優れている点としては  
1. 途中の削除、挿入が高速  
2. イテレーターが無効にならない  
ひとまずイテレーターをポインタと思うと、vectorの場合要素が増えてきたときメモリの再確保が行われて別のポインタにすべて移動するので元のポインタを保持していても先に何があるか全く保証されない(エラーを吐くようにイテレータが設計されている)が、listの場合要素数がどう変動してもその要素を消さなければメモリ上動くことはないのでポインタをずっと保持していても先にあるデータは変わらないということである。  

劣っている点としては  
1. 要素数を取得するとき計算量が多い  
2. データの場所を保存する分データ量がかさむ
3. ランダムアクセスに時間がかかる  

ランダムアクセスというのは、最初からすべての要素を見ていくわけではなく順番ばらばらにアクセスする方法のことである。  
listには最初と最後の要素しか保存されていないのでどこを見るにも最初または最後から順番に見ていく必要があるのでlistにとっては苦手である。  

要素数やランダムアクセスを行わないもので途中に挿入したり削除したりするようなものはlistで管理するべきだろう。  
シューティングの弾がいい例である。  

# 練習問題

int型のlistを作成し、適当な要素をメンバ関数emplace_backを利用して追加せよ。  
range-based forを利用してすべての要素を表示せよ。  
メンバ関数eraseを利用して途中の要素を一つだけ削除し再度表示せよ。  
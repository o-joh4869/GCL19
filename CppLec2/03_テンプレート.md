## ゲーム制作講座
テンプレートは、この資料で表立って使うことは少ないが、リファレンス等を見た時よく出てくるので基本的なところをまとめておく。  

# テンプレートとは

関数のオーバーロードでは、引数の型や数を変えることで同じ関数名でも複数定義できた。  
しかし、たいていの場合は関数の中身は同じで、別に定義するのが面倒な場合もある。  
さらにこれがクラスになると同じ名前のものは再定義できないので、float型ならMyClassfなど複数定義を書く必要があった。  

テンプレートとよばれるものを利用することで型を明確に決定しないままクラス等を定義し、この問題を解決する。  

# 書き方

テンプレートは以下のように宣言する。  
```cpp
template<class T>
```

ここで登場したTは変数名と一緒で自由に決められる。  
このTをテンプレートパラメータと呼び、すべてのテンプレートパラメータをまとめてパラメータリストと呼ぶ。  

末尾にセミコロンがついていないことに気が付いただろうか。  
ここで宣言されたTのスコープはこの直後に定義される関数またはクラス内のみである。  

テンプレートを利用してMyClassクラスを定義してみよう。  

```cpp
template<class T>
class MyClass {
public:
    MyClass(T a, T b) : 
        a(a),
        b(b)
    {}
    T a;
    T b;
};
```

このように、クラス内でTは普通の型のように使用できる。  

MyClassのインスタンスを生成するときは、
```cpp
MyClass obj<int>(10, 30);
```
のように<>で型を指定する。  

関数テンプレートは、テンプレートパラメータがすべて引数から推測できるとき型指定を省略できる。  
思わぬ挙動を引き起こす恐れがあるので指定することを勧める。  

# テンプレートと演算子オーバーロード

演算子の定義にテンプレートを用いることができる。  

```cpp
class MyClass {
public:
    MyClass(int a) :
        a(a)
    {}

    template<typename T>
    MyClass operator+(const T &t) const {
        return MyClass(a + (int)t);
    }
    
    operator int() const {
        return a;
    }
}
```

このとき、仮置きの型はすべて引数から推測できるものでなくてはいけない。  

# テンプレートとファイル分け

テンプレートを利用して作られた仮置きの型をもつパラメータはコンパイル時に決定する。  
つまり、コンパイル時に型がわからなかったらコンパイルできない。  

ファイル分けの回で詳しく話すが、コンパイルはcppファイルごとに行われる。  
もし普通のクラスのようにメンバ関数の中身を他のcppファイルで定義した場合、そのcppファイルをコンパイルするときにコンパイラが型を決定できずエラーを吐く。  

これを回避する方法はいくつかあるが、最も簡単なものはヘッダーファイルにすべて書いてしまうことである。  
この資料の中ではすべてヘッダーファイルに書いている。  

# 練習問題

テンプレートパラメータを2つ持ち、それぞれのインスタンスを持つVector2クラスを用意した。  

```cpp
template<class T>
class Vector2 {
public:
    Vector2(T x, T y) : 
        x(x),
        y(y)
    {}

    T x;
    T y;
};
```

このクラスに対して+演算子と-演算子を定義せよ。  
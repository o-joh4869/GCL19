## ゲーム制作講座
***
テンプレートは、この資料では座標を表すクラスでしか利用しないが、リファレンス等を見た時よく出てくるので基本的なところをまとめておく。

# テンプレートとは

関数のオーバーロードでは、引数の型や数を変えることで同じ関数名でも複数定義できた。  
しかし、たいていの場合は関数の中身は同じで、わざわざ別に定義するのが面倒な場合もある。  
さらにこれがクラスになると同じ名前のものは再定義できないので、float型ならMyClassfなど複数定義を書く必要があった。  

テンプレートとよばれるものを利用することで型をあいまいにしたままクラス等を定義し、この問題を解決する。

# 書き方

テンプレートは以下のように宣言する。  
```cpp
template<class T>
```

ここで登場したTは変数名と一緒で自由に決められる。  

この文にセミコロンがついていないことに気が付いただろうか。  
ここで宣言されたTはこの直後に定義される関数またはクラス内でのみ有効である。  

テンプレートを利用してMyClassクラスを定義してみよう。  

```cpp
template<class T>
class MyClass {
public:
    MyClass(T a, T b) : 
        a(a),
        b(b)
    {}
    T a;
    T b;
};
```

このように、クラス内ではTは普通の型のように使用できる。  

MyClassのインスタンスを生成するときは、
```cpp
MyClass obj<int>(10, 30);
```
のように<>で型を指定する。  
指定しなくてもコンストラクタの引数にtemlateで定義されたあいまいな型があった場合は、引数からコンパイラが型を推定してくれる。  
思わぬ挙動を引き起こす恐れがあるので指定することを勧める。  

# テンプレートと演算子

テンプレートで定義されたクラスもメンバ関数を持つことができる。  
しかし、その中であいまいな型のメンバ変数を利用しようとしたとき問題が生じる。  
あいまいな型がはっきり決まるのはコンパイルの時である。  
もしあいまいな型を別の関数に渡す処理をしていたとき、関数が定義されていない型に置き換わったらコンパイルエラーになってしまう。  
そのような型を指定しないのならいいが、そんなこと忘れて書いてしまうかもしれないし、 別の人間がコードを書くことになるかもしれない。  
そもそもテンプレートは幅広い型で使用するものなのでそんなクラス自体普通に定義するべきなのである。  
幅広い型で定義されている関数といえば演算子である。  
メンバ関数内で使用する関数は演算子のみになる場合が多い。  

# テンプレートとファイル分け

テンプレートを利用して作られたあいまいな型をもつ変数はコンパイル時に型が判断される。  
逆にいえば、コンパイル時に型がわからなかったらコンパイルできないのだ。  

ファイル分けの回で詳しく話すが、コンパイルはcppファイルごとに行われる。  
もし普通のクラスのようにメンバ関数の中身を他のcppファイルで定義した場合、そのcppファイルをコンパイルするときにコンパイラが型を決定できずエラーを吐く。  

これを回避する方法はいくつかあるが、最も簡単なものはヘッダーファイルにすべて書いてしまうことである。  
この資料の中ではすべてヘッダーファイルに書いている。  

# 練習問題

あいまいな型のメンバ変数を2つ持つVector2クラスを用意した。  

```cpp
template<class T>
class Vector2 {
public:
    Vector2(T x, T y) : 
        x(x),
        y(y)
    {}

    T x;
    T y;
};
```

このクラスに対して+演算子と-演算子を定義せよ。  
## ゲーム制作講座
***
スマートポインタの一つであるunique_ptrについて紹介する。  
目標は関数にunique_ptrを渡して、unique_ptrを返すところまでを理解することである。  

# スマートポインタとは

動的にメモリを確保するためにnewというものがあった。  
Cのmallocというものもあったがクラスのコンストラクタを呼ぶことができないためnewが主に使われる。  

しかしnewしたものはdeleteする必要があり、開放し忘れはメモリリークを引き起こす。  
このミスを防ぐために作られたのがスマートポインタというものである。  
簡単な仕組みとしては、newされたポインタの管理をクラスで行いデストラクタでdeleteするというものだ。  
(ポインタを管理する権利を所有権という)

C++講座の方ではshared_ptrを紹介したが、ここでは本編の都合上unique_ptrを紹介する。  
大きな違いとしては、unique_ptrはコピーや代入を行った際に元のクラスのポインタをnullptrにするという点である。  
言い換えれば、そのポインタに対する所有権を持つunique_ptrはただ一つであるということだ。  

# 書き方

unique_ptrを使用するにはshared_ptr同様memoryをインクルードする必要がある。  

```cpp
#include<memory>
```

書き方は
```cpp
std::unique_ptr<int> p;
```

である。  

# ポインタを渡す

このままではインスタンスは生成していない。  
生成したいクラスのコンストラクタの引数がunique_pt側からはわからないのでインスタンスの生成は外部で行い、そのポインタを渡してあげる必要がある。  

unique_ptrにポインタを渡す方法はいくつかある。  

一つ目はコンストラクタで渡してしまう方法だ。  
```cpp
std::unique_ptr<int> p(new int(10));
```

二つ目はメンバ関数のresetを利用する方法だ。
```cpp
std::unique_ptr<int> p;
p.reset(new int(10));
```
reset関数は、もともと所持していたポインタをdeleteして新しいポインタを所持する。  
コンストラクタでポインタを渡さなかった場合はnullptrを持っているので結果ポインタを渡しただけになる。  

# make_unique

unique_ptrにポインタを渡すとき、newをして渡していた。  
これではうまくいかない場合があるので用意されているmake_uniqueを利用する。  
(例外について今回は説明しない)

```cpp
std::unique_ptr<int> p(std::make_unique<int>(10));
```

make_uniqueの返り値はunique_ptr型であるため、ここで呼ばれているのは通常のコンストラクタではなくムーブコンストラクタと呼ばれるものである。  
この時unique_ptr型の一時オブジェクトが持っているポインタを受け取ってpが生成され、一時オブジェクトは保持していたポインタをnullptrに書き換えてから解放される。  

こうしてunique_ptrにポインタを渡すことができた。  

また、make_uniqueを使う場合ムーブコンストラクタを呼んでいるので
```cpp
std::unique_ptr<int> p = std::make_unique<int>(10);
```

のように=の記号を使うこともできる。  
これは代入演算子ではないことに注意しよう。  

# 代入演算子

unique_ptrは代入演算子が定義されている。  
一言で言ってしまえば所有権を譲渡するということを行える。  

```cpp
std::unique_ptr<int> p1 = std::make_unique<int>(3);
std::unique_ptr<int> p2;

p2 = std::move(p1);
```

こうすることでp1にはnullptrがはいり、p1にもともと入っていた(int)3のポインタはdeleteされずにp2に移る。  

また、所有権の放棄(メモリの開放)も代入演算子で行える。  
```cpp
std::unique_ptr<int> p = std::make_unique<int>(10);
p = nullptr;
```

# deleteされるタイミング

何らかの方法でunique_ptrにポインタを渡すことができたら、あとはunique_ptrのデストラクタが実行されるときに勝手にdeleteしてくれる。  

そのほかにも前述したreset関数を用いれば前に持っていたポインタはdeleteされる。  

# 使い方

unique_ptrにはアロー演算子や*などが定義されていて、通常のポインタと同様に扱うことができる。  

しかし関数に渡したりするときは少し異なっていて、本当のポインタを取得する必要がある。　　
(unique_ptrをクラスとして渡すこともできなくはないがやや煩雑なため今回は触れない)  
そのために用意されたメンバ関数としてgetとreleaseある。  

get関数はそのポインタが返ってくる。  
```cpp
std::unique_ptr<int> p = std::make_unique<int>(10);
int *p2 = p.get();
```

release関数もポインタが返ってくるが、所有権を放棄する。  
この関数を一度呼ぶとunique_ptrのデストラクタでdeleteはされず、自分でdeleteする必要がある。  
また、release後はnullptrを持つ。  
```cpp
int *p2;
{
    std::unique_ptr<int> p = std::make_unique<int>(10);
    p2 = p.release();
}
delete p2;
```

# unique_ptrとポリモーフィズム

スマートポインタでもpublic継承を利用したポリモーフィズムができる。  
あるクラスBaseを継承したDerivedクラスを用意して、
```cpp
Base *p = new Derived();
```
のように自動的にキャストされた。(派生クラスのポインタから基底クラスのポインタへのキャストとをアップキャストという。)  

スマートポインタでもほぼ同様に書くことができる。  
```cpp
std::unique_ptr<Base> p = std::make_unique<Derived>();
```

この時に一つ違う点がある。  
ポリモーフィズムの基底となるクラス(今回はBaseクラス)で純粋仮想関数を作成できないという点だ。  
これはunique_ptrの中でnewに準ずる処理をしていることに起因する。  

純粋仮想関数にしていた部分を空の関数として定義する必要がある。  
コードの保守性を気にするなら呼ばれたらエラーを投げるようにthrowしてあげてもいいと思う。  
さらにいえば、Baseのインスタンスを生成しなければいいので、コンストラクタが派生クラスからのみ呼ぶことができればいいことを考慮するとprotectedにしてもいいだろう。  

# 練習問題

int型のunique_ptrを作成し、そのポインタをint型のポインタ型を引数に持つ関数にget関数を用いて渡せ。  

関数をint型のポインタ型を返す形に変更せよ。  
別のインスタンスを作成してそのポインタを返せ。  
unique_ptr型のインスタンスが持っているポインタを返ってきたポインタにresetせよ。  

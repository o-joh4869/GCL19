## ゲーム制作講座
C++講座のほうで簡易的にしか紹介されていなかったため再度まとめなおす。  

# アクセス修飾子とは

クラスのメンバはクラスの外部からアクセス可能であるか、メンバ関数からのみしかアクセスできないかを指定することができる。  

```cpp
class Hoge {
public:
    Hoge();
    int a;
};
```

二行目にあるpublicがアクセス修飾子である。  
この例ではコンストラクタとメンバ変数aがpublicである。  

# 種類

アクセス修飾子は
```cpp
public:
protected:
private:
```
の3種類ある。  

publicはすべて外部からもメンバ関数からもアクセス可能になる。  
protectedは外部から直接アクセスはできないが、そのクラスのメンバ関数と継承先のメンバ関数からアクセスできる。  
privateはそのクラスのメンバ関数からしかアクセスできない。  

privateやprotectedを活用していくことで予期せぬ値の書き換わりを防止することができる。  
特に複数人で開発するときには必須の技術だ。  

```cpp
class Hoge {
public:
    Hoge() {}
    void f() {
        //メンバ関数からはすべてアクセス可能
        pub = 10;
        mPro = 20;
        mPri = 30;
    }
    int pub;
protected:
    int mPro;
private:
    int mPri;
};

int main() {
    Hoge hoge; //コンストラクタがpublicなのでインスタンスを作成可能
    hoge.f(); //メンバ関数fはpublicメンバなのでアクセス可能
    hoge.pub = 11; //アクセス可能
    //hoge.mPro = 22; //protectedなのでアクセス不可
    //hoge.mPri = 33; //privateなのでアクセス不可
    // ↑ コメントアウトを外すとコンパイルエラー
}
```

## Tipps : 命名の慣習
protectedやprivateのメンバの名前の先頭にmを付けていることに気が付いただろうか。  
変数や関数の名前を見たときに一発で外部からアクセス可能かどうかを知ることができるための慣習らしい。  
誰か別の人がコードを読むときにわざわざ定義部分に戻らなくてもある程度アクセス修飾子を知ることができるいい方法である。  

# privateメンバの値を取得する

privateやprotectedなメンバでも、外部から値だけほしい場合がある。  
publicにしてしまう手もあるが外部からは値を変更せずにその値を利用するだけの場合意図しない値の変更が起こりかねない。(==, =のミスなど)  

値だけを取得する方法は大きく分けて2つある。  

1つ目は関数を利用する方法だ
```cpp
class Hoge {
private:
    int m_a;
public:
    const int &get_a() const {
        return m_a;
    }
};
```
こうすることで、関数を通して値を取得できる。  
C++14以降では返り値の型をコンパイラに推測させて
```cpp
const auto &get_a() const {
    return m_a;
}
```
とすることもできる。  

## 参照型の返り値
関数はポインタを返すのと同様に参照型を返すことができる。  
本来であればアクセスできないメンバ変数m_aにget_a関数を通してm_aのconst参照をもらうことができる。  
この時、返すものはその関数を抜けてもメモリが解放されないものである必要があることに注意しよう。  

2つ目はconst参照型をpublicメンバに持たせる方法だ。  
```cpp
class Hoge {
private:
    int m_a;
public:
    const int &a;
    Hoge() : 
        a(m_a)
    {}
};
```
参照型のメンバaを通してm_aの値を取得できる。  
この時注意すべきなのは参照型のメンバを持つ場合、イニシャライザで初期化する必要があることである。  
それさえ気を付ければ、呼び出しのとき()が必要だった関数よりも扱いやすい。  

本講座では前者を採用する。  
関数を通すことでブレークポイントを用いたデバッグがしやすいためだ。  

# 継承するときのアクセス修飾子

継承するときにもアクセス修飾子をつける。

```cpp
class Base() {
public:
    Base() {}
};

class Derived : public Base {
public:
    Derived() :
        Base()
    {}
};
```

6行目からBaseクラスをpublic継承したDrivedクラスを定義している。  

public継承では基底クラスのメンバのアクセス修飾子をそのまま引き継ぐ。
基底クラスでprivateだったメンバは基底クラスの関数からしかアクセスできず、派生クラスの関数からはアクセスできないことは注意しよう。  

protected継承は、publicメンバをprotectedにして引き継ぐ。  
private継承は、publicメンバとprotectedメンバをprivateにして引き継ぐ。  

protected継承はその派生クラス自身だけでなく、それをさらに継承したクラスにも見えるという点で若干違いはあるが大筋はprivate継承と変わらない。  
どちらも基底クラスのポインタ変数に派生クラスのインスタンスのポインタを入れることはできない。  
この講座ではpublic継承のみを使うので気にしなくて大丈夫だ。  

# 練習問題

次のクラスはメンバがすべてpublicである。  
適切にprivate化せよ。  
privateメンバの先頭にmまたはm_を付けるのを忘れないこと。  

```cpp
class Enemy {
public:
    Enemy(int x, int y);
    void update(int prx, int pry);
    void draw() const;
    int x;
    int y;
    int grHandle;
};

Enemy::Enemy(int x, int y) : 
    x(x), y(y),
    grHandle(0) //本来ロードしてハンドルを入れる
{
}

void Enemy::update(int prx, int pry) {
    //引数で得たprx,pryに応じてメンバx,yを変更する処理
}

void Enemy::draw() const {
    //メンバx,y及びgrHandleに応じて描画する処理
}
```
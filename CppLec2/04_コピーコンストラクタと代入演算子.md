## ゲーム制作講座
***
シングルトンの話をするのに必要不可欠な知識がコピーコンストラクタと代入演算子だ。  

# コピーコンストラクタ

コピーコンストラクタとは、クラスのインスタンスを生成するときに呼ばれるコンストラクタの1つで、引数に自分自身のconst参照型を入れることでメンバをコピーしたインスタンスを生成する。  

```cpp
class Hoge {
public:
    Hoge() {} //通常のコンストラクタ
    Hoge(const Hoge &o) {} //コピーコンストラクタ
    int a;
};

int main() {
    Hoge hoge; //通常のコンストラクタ
    Hoge hoge2(hoge); //コピーコンストラクタ
    Hoge hoge3 = hoge; //コピーコンストラクタ
    return 0;
}
```

初期化時にン別のインスタンスを指定したときと、値渡しの関数が呼ばれたときにコピーコンストラクタが呼ばれる。  

```cpp
class Hoge;

void f(Hoge hoge);

int main() {
    Hoge hoge; //通常のコンストラクタ
    f(hoge); //コピーコンストラクタ
}
```

関数が呼ばれたときにコピーコンストラクタを呼びたくない場合が多く(後述)、関数の引数は参照型で指定することが多い。  
参照型の初期化時は実体を生成しているわけではないのでコピーコンストラクタは呼ばれない。  
```cpp
class Hoge;

void f(const Hoge &hoge);

int main() {
    Hoge hoge;
    f(hoge);
}
```

# コピー代入演算子

コピー代入演算子は=で表される演算子でメンバのコピーを行う。  

```cpp
class Hoge {
public:
    Hoge &operator= (const Hoge &o) {}
};
```

# 暗黙宣言

コピーコンストラクタとコピー代入演算子は自分で定義しなくても勝手に宣言される。  

```cpp
class Hoge {

}

int main() {
    Hoge hoge;
    Hoge hoge2(hoge);
}
```

と書いても正常に動作する。  

デフォルトのコピーは各メンバ変数のコピーを実行している。  
そのため、メンバでポインタを管理するときには注意が必要だ。  
```cpp
class Hoge {
public:
    Hoge() : p(new int) {}
    ~Hoge() { delete p; }
    int *p;
}

void f(Hoge h) {
}

int main() {
}
```

# コピーを禁止する

インスタンスのコピーはこれらをprivateメンバにすれば大半は防ぐことができる。  

```cpp
class Hoge {
private:
    Hoge(const Hoge&) {}
    Hoge &operator= (const Hoge &) {}
public:
    Hoge() {}
};
```

# delete宣言

C++にはdelete宣言というものがある。  
クラスを定義したときに暗黙に定義されるコンストラクタやデストラクタなどを定義させないようにできる。  
書き方は=deleteとするだけである。  
```cpp
class Hoge {
private:
    Hoge(const Hoge&) = delete;
    Hoge &operator= (const Hoge &) = delete;
public:
    Hoge() {}
};
```

こうすることでコピーの発生をコンパイル段階ではじくことができる。  

# コピーを禁止する理由

インスタンスのコピーを禁止する理由はいくつかある。  
そのなかでも、ポインタ変数をメンバに持つクラスについて紹介する。  

下のクラスを見てほしい

```cpp
class Hoge {
public:
    Hoge(int a) { p = new int(a); }
    ~Hoge() { delete p; }
    int *p;
};
```

コンストラクタでnewしてデストラクタでdeleteしている。

デフォルトのコピーコンストラクタや代入演算子はメンバのコピーのみを行うため、一度コピーが発生してしまうとポインタ変数の指し示す先が同じインスタンスが2つ生成されてしまう。  
その後デストラクタで同じポインタを二度deleteしてしまうためエラーになってしまう。  

コピーコンストラクタと代入演算子をコピーが発生しても問題ないように自分で定義してあげれば解決できるが、コピーすることが必要ない場合がほとんどであるため禁止してしまうのが手っ取り早いだろう。  

# 練習問題

次のクラスのコピーコンストラクタと代入演算子をprivateメンバにせよ。  
関数の中身は特に指定しない。  
```cpp
class MyClass {
public:
    MyClass(int x, int y) : 
        x(x),
        y(y)
    {
    }
    int x;
    int y;
};
```
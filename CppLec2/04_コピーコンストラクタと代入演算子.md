## ゲーム制作講座

何も知らないと書いてしまいがちなコードの問題点から暗黙定義される特殊メンバ関数について紹介する。  

# 問題のコード

```cpp
class Hoge {
public:
    Hoge() : p(new int(0)) {}
    ~Hoge() { delete p; }
    int *p;
};

void f(Hoge h) {
    *(h.p) = 10;
}

int main() {
    Hoge h;
    f(h);
    return 0;
}
```

一見問題なさそうなコードだが、実行時にエラーが吐かれる。  
この問題の原因は暗黙宣言されたコピーコンストラクタの存在だ。  

# コピーコンストラクタ

コピーコンストラクタとは、自身のクラスのインスタンスのみを参照渡しして呼び出せるコンストラクタである。  
※厳密な定義は[cppref](https://ja.cppreference.com/w/cpp/language/copy_constructor)等を参照  

```cpp
class Hoge {
public:
    Hoge() {} //通常のコンストラクタ
    Hoge(const Hoge &o) {} //コピーコンストラクタ
    int a;
};

int main() {
    Hoge hoge; //通常のコンストラクタ
    Hoge hoge2(hoge); //コピーコンストラクタ
    Hoge hoge3 = hoge; //コピーコンストラクタ
    return 0;
}
```

初期化時に別のインスタンスを指定したときと、値渡しの関数が呼ばれたときにコピーコンストラクタが呼ばれる。  

```cpp
class Hoge;

void f(Hoge hoge);

int main() {
    Hoge hoge; //通常のコンストラクタ
    f(hoge); //コピーコンストラクタ
}
```

関数が呼ばれたときにコピーコンストラクタを呼びたくない場合が多く(後述)、関数の引数は参照型で指定することが多い。  
参照型の初期化時は実体を生成しているわけではないのでコピーコンストラクタは呼ばれない。  
```cpp
class Hoge;

void f(const Hoge &hoge);

int main() {
    Hoge hoge;
    f(hoge);
}
```

# デフォルトコピーコンストラクタ

コピーコンストラクタはユーザ定義しなかった場合暗黙に定義される。  

```cpp
class Hoge {
public:
    Hoge() {} //通常のコンストラクタ
};

int main() {
    Hoge hoge; //通常のコンストラクタ
    Hoge hoge2(hoge); //コピーコンストラクタ
}
```

暗黙に定義されたコピーコンストラクタをデフォルトコピーコンストラクタと呼ぶ。  
デフォルトコピーコンストラクタの中身は、各メンバ変数についてコピーコンストラクタを呼び出すというものである。  
基本型は値のコピーを行う。  

# デフォルトコピー代入演算子

コピー代入演算子もコピーコンストラクタ同様ユーザ定義しなかった場合暗黙に定義される。  
デフォルトコピー代入演算子の中身はコピーコンストラクタ同様各メンバ変数についてコピー代入演算子を呼び出す。  

## Tipps:暗黙に定義される特殊関数

コンストラクタも書かなければ暗黙に定義される。  
```cpp
class Hoge {
public:
    int a;
};

int main() {
    Hoge h; //OK
    return 0;
}
```
各メンバの引数なしのコンストラクタを呼び出す。  
基本型は整数型なら0のようにそれぞれ決められている。  
特に意識して書くことは無かったかもしれないが、デストラクタも暗黙に定義される。  
ほかにムーブセマンティクス周りのものがあるが、特段問題になることは少ないので割愛する。  

# 何が問題か

問題のコードに戻ろう。  

```cpp
class Hoge {
public:
    Hoge() : p(new int(0)) {}
    ~Hoge() { delete p; }
    int *p;
};

void f(Hoge h) {
    *(h.p) = 10;
}

int main() {
    Hoge h;
    f(h);
    return 0;
}
```

コピーコンストラクタは値渡しの関数の実行時にも呼ばれるため、このコードでは関数fが呼ばれたときに呼び出される。  
コピーコンストラクタの内容は、ユーザー定義されていないのでデフォルトのものである。  
すなわち、fの仮引数hがメンバに持つポインタと、main関数内のhがメンバに持つポインタの示す先は同じオブジェクトである。  
関数fが終了すると仮引数hのデストラクタが呼ばれ、ポインタpの先にあるメモリは解放される。  
最後にmain関数が終了するとhのデストラクタが呼ばれるが、このhが持つポインタの先のメモリはすでに解放されているのでエラーを吐く。  

# 解決方法1 : コピー禁止+参照渡し

コピーを禁止する方法がある。  

```cpp
class Hoge {
public:
    Hoge(); //通常のコンストラクタ
    Hoge(Hoge &) = delete; //コピーコンストラクタの削除
    Hoge &operator= (Hoge &) = delete; //コピー代入演算子の削除
};
```

コピーコンストラクタやコピー代入演算子の後ろに書いた=deleteはdelete宣言と呼ばれるものだ。(後述)  
とりあえずコピーを禁止するおまじないとでも思っておいてほしい。  

コピーを禁止したら関数に値渡しすることができない。  
参照型を用いることはできるので
```cpp
void f(Hoge &h);
```
とすればいい。  
値渡しをしていた関数内から、元のインスタンスの内容を変更することはないのでconst参照にして  
```cpp
void f(const Hoge &h);
```
とすることが多い。  

## delete 宣言

delete宣言した関数は明示的にその関数の生成、使用を禁止することができる。  
関数f()をdelete宣言するには
```cpp
void f() = delete;
```
と、関数の宣言の後ろに=deleteをつける。  

# 解決方法2 : コピーの内容を定義する

コピーコンストラクタとコピー代入演算子をバグが起きないように書き換えることで解決できる。  

```cpp
class Hoge {
public:
    Hoge() : p(new int) {}
    ~Hoge() { delete p; }
    Hoge(const Hoge &h) : p(new int(*h.p)) {}
    Hoge &operator= (const Hoge &o) {
        p = new int(*o.p);
        return *this;
    }
    int *p;
};
```

自分で定義を書く場合、メンバ変数が増える度にそのメンバについて書き加える必要がある。  
書き忘れによるバグが発生しかねないので、どうしてもコピーが必要になるまでは削除しておくのが妥当だろう。  

# 練習問題

次のクラスについて、適切なコピーコンストラクタとコピー代入演算子を定義せよ。  

```cpp
class MyClass {
public:
    MyClass(int x, int y) : 
        x(x),
        y(y)
    {
    }
    int x;
    int y;
};
```
## ゲーム制作講座

# #includeの仕様

```#include``` はコンパイル前に指定したファイルの内容をその場所に貼り付ける。  
ファイル分けの際にヘッダーファイルを通して特殊な処理が行われているわけではない。  

## Tipps : includeの悪用

csvファイルの内容を直接配列に渡すこともできる。  
```cpp
int arr[] = {
    #include"data.csv"
};
```

# インクルードコスト

あるヘッダーファイルにおいて、どれくらいの数のcppファイルにインクルードされているかを表す言葉としてインクルードコストというものがある。  
多くのファイルにインクルードされていればインクルードコストが高い、逆は低いという。  

# リコンパイル

一度コンパイルされたファイルを再度コンパイルすることをリコンパイルという。  
ファイルの内容が変更されたらリコンパイルが必要になる。  
VisualStudio含む多くのIDEは変更されたファイルのみをリコンパイルするように設計されている。  
ヘッダーファイルが変更されたとき、それをインクルードしているcppファイルもリコンパイルされる。  
インクルードコストが高いファイルを作ってしまうとリコンパイルにかかる時間が膨大になってしまう。  
大きなプロジェクトでは全体をリコンパイルすると数時間ないし数日かかるものもある。  
個人製作の範囲でも数分から数十分かかることも十分ありうる。  
そのため、インクルードコストを減らすコーディング技術が必要になってくる。  

# コンポジションと集約

クラスとメンバ変数との関係性を表す言葉にコンポジションと集約がある。  

クラスのメンバ変数が指すインスタンスの寿命がそのクラスのインスタンスと同じときをコンポジションという。  
つまり、ポインタ型や参照型ではなく普通にメンバ変数に指定した場合はコンポジションである。  
他に、コンストラクタでnewしてデストラクタでdeleteしたものもコンポジションである。  

```cpp
/* コンポジション1 */
class A {

};

class B {
    A a;
};
```

```cpp
/* コンポジション2 */

class A {

};

class B {
    A *a;
public:
    A() : 
        a(new A)
    {}

    ~A() {
        delete a;
    }
};
```

ポインタ型をメンバに持ち、代入するポインタの指すインスタンスの管理を外部で行うことを集約という。  

```cpp
/* 集約 */
class A {

};

class B {
    A *p;
public:
    B(A *p) : 
        p(p)
    {}
};
```

# コンポジションとファイル分け

まずは次のコードを見てほしい。  

```cpp
/* A.hpp */
class A {
public:
    A();
};
```

```cpp
/* A.cpp */
#include"A.cpp"

A::A() {
}
```

```cpp
/* B.hpp */
#include"A.hpp"
class B {
public:
    B();
    A a;
};
```

```cpp
/* B.cpp */
#include"B.hpp"
B::B() : 
    a()
{}
```

```cpp
/* C.hpp */
#include"B.hpp"
class C {
public:
    C();
    B b;
};
```

```cpp
/* C.cpp */
#include"C.hpp"

C::C() : 
    b()
{}
```

AのインスタンスをBが、BのインスタンスをCが持っている。  
このコードでは、A.hppに変更を加えたときすべてのcppファイルでリコンパイルされてしまう。  
クラスの宣言を利用することで解決できる。  

```cpp
/* A.hpp */
class A {
public:
    A();
};
```

```cpp
/* A.cpp */
#include"A.cpp"

A::A() {
}
```

```cpp
/* B.hpp */
class A; //Aを宣言
class B {
public:
    B();
    ~B();
    A *a; //ポインタ型は利用可能
};
```

```cpp
/* B.cpp */
#include"A.hpp" //Aの実体を作るので必要
#include"B.hpp"
B::B() : 
    a(new A)
{}

B::~B() {
    delete a;
}
```

```cpp
/* C.hpp */
class B; //Bの宣言
class C {
public:
    C();
    ~C();
    B *b;
};
```

```cpp
/* C.cpp */
#include"B.hpp"
#include"C.hpp"

C::C() : 
    b(new B)
{}

C::~C() {
    delete b;
}
```

A.hppに変更を加えてもC.cppやC.hppをインクルードしたcppファイルはリコンパイルされない。  

このコードはコピーが発生したときに安全ではない。  
また、deleteし忘れも発生しうるためスマートポインタを用いた方法に書き直す。  

```cpp
/* A.hpp */
class A {
public:
    A();
    ~A();
};
```

```cpp
/* A.cpp */
#include"A.cpp"

A::A() {
}

A::~A() {
}
```

```cpp
/* B.hpp */
#include<memory>
class A; //Aを宣言
class B {
public:
    B();
    ~B();
    std::unique_ptr<A> a;
};
```

```cpp
/* B.cpp */
#include"A.hpp"
#include"B.hpp"
B::B() : 
    a(std::make_unique<A>())
{}

B::~B() {
}
```

```cpp
/* C.hpp */
#include<memory>
class B; //Bの宣言
class C {
public:
    C();
    ~C();
    std::unique_ptr<B> b;
};
```

```cpp
/* C.cpp */
#include"B.hpp"
#include"C.hpp"

C::C() : 
    b(std::make_unique<C>())
{}

C::~C() {
}
```

デストラクタに何も書いていないのに宣言と定義を分けて書いている。  
スマートポインタをメンバに持つとき、デストラクタがインラインだとこの方法はコンパイルエラーになってしまう。  

デストラクタが呼ばれた直後、各メンバ変数のデストラクタが呼ばれる。  
デストラクタがインラインだと、この処理もインライン化される。  
スマートポインタのデストラクタでは、delete演算子が呼ばれる。  
delete演算子はその型の定義が必要だが、ヘッダーファイルではその型の定義が書かれたヘッダーファイルがインクルードされていないためコンパイルエラーになってしまう。  

テンプレートの知識があれば、クラスの宣言時にデストラクタをextern templateして、デストラクタの定義があるcppファイルで明示的インスタンス化すれば解決できる。  
しかしそんな知識がなくても、デストラクタをインライン化させなければいい。  
結局インライン化されていない関数の呼び出しはどちらも一回なので、後者を採用するといいだろう。  

# コンパイル時間と実行時の処理速度

ここまでインクルードコストを下げる方法を紹介してきたが、最初の方法のようにすべてインクルードしてしまった方がいい場合もある。  
すべてのファイルでこの方法を用いると、ほとんどインライン化されないため実行時の処理速度が落ちてしまう可能性がある。  
特に、短い時間で大量にインスタンスを作成、破棄するようなクラスではデストラクタの呼び出し時間が致命的になりうる。  
ある一定のラインからコンパイル時間と処理速度は比例的に変化するので開発環境と相談しながらいいところで折り合いを付ける必要がある。  

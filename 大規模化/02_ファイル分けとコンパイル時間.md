## ゲーム制作講座
***
ファイル分けをする理由はいくつかある。  
規模が大きくなってくると該当箇所を探すのが大変だったり、誰かとコードを書くときに1つのファイルだと面倒が多かったりなどである。  
今回は具体的なファイル分けの方法を、コンパイル時間を視野に入れて紹介する。  
なお、基本的なファイル分けの方法は既に知っているものとして話を進める。  

# #include
```cpp
#include"ファイル名"
```
というプリプロセッサ命令について確認する。  
これは、コンパイル前に指定されたファイルの内容をそのまま張り付けるものである。(詳しいことは知らない)  

大きくは違ってないと思うのでこのことをよく覚えておいてほしい。  

# 関数のファイル分け

まずは比較的簡単な関数から見ていこう。    

```cpp
/* Main.cpp */

#include<iostrem>

void f(); // 宣言

int main() {

    f();

    return 0;
}

void f() {
    // 定義
}

```

これをmain関数の定義されているMain.cppと関数fの定義されているfunction.cppファイルに分ける。  

main関数内で関数fを使っているため、その前に宣言が必要である。  
VisualStudioを通して作成されたcppファイルは、VisualStudioを通してコンパイルした時に勝手に紐づけされる。  
つまり、識別子(変数名や関数名など)さえ一致させておけば同一の変数や関数にアクセスできる。  

識別子を同一にする方法として大きく二種類ある。  

一つ目はヘッダーファイルを用いることだ。  
つまり、

```cpp
/* function.h */
#pragma once
void f(); //宣言
```
```cpp
/* function.cpp */
#include"finction.h"

void f() {
    // 定義
}
```
```cpp
/* Main.cpp */
#include<iostrem>
#include"function.h"

int main() {

    f();
    
    return 0;
}
```

とできる。  

もう一つはMain.cppに直接宣言を書き込む方法である。  
つまり、

```cpp
/* function.cpp */
void f() {
    // 定義
}
```
```cpp
/* Main.cpp */
#include<iostream>

void f(); // 宣言

int main() {

    f();

    return 0;
}
```

とできる。  

二つ出てきたらどちらが良いかということを議論する必要がある。  
「良さ」というきわめて抽象的な指標に対して、コンパイル時間という具体的な指標から議論を進める。  
結論から言ってしまえば前者の方法であるが、下に長々と書かれていることはとても重要なので一度は目を通してほしい。  

コンパイルするのに最も時間がかかる工程はヘッダーファイルの処理といわれている。(たぶん)  
コンパイル時間は小規模なうちはほとんど一瞬で終わってしまうものであり、特に気にするものではない。  
しかし、ゲームが大規模になってくると当然ファイルの数も多くなってきて、コンパイル時間も増えてくる。  
特に大規模になってくるとファイル数が100や1000を超えてくるものも珍しくなく、すべてをコンパイルするのに数時間かかるものもある。  
これでは拡張機能の実装なんてできたものではない。  
VisualStudioにはcppファイルをコンパイルする際その内容が変更されていなければ前にコンパイルしたときのものをそのまま用いるという機能がある。(大抵のIDEには実装されてそう)  
これをうまく用いれば関連する項目のみをコンパイルしなおしてそれ以外はそのまま使って大規模なプロジェクトにおいても非常に短い時間でコンパイルを終えることができる。  
しかし、これを利用するためには#includeがとてもやっかいである。  
cppファイル内のincludeは、指定されたファイルの内容がそのまま張り付けられてからコンパイルされる。  
cppファイル内が変わっていなくてもincludeの先が変更されたら当然コンパイルしなおしである。  
そのため、ヘッダーファイルにはそうそう変更されないであろうことのみを書く必要がある。  

今回は関数をファイル分けしようとしている。  
関数の宣言は返り値の型、関数名、引数の型や数で構成されている。  
これは関数を使う側にとって必要十分な情報であり、これを変更するときはこの関数を使うすべてのcppファイルで宣言部分が変更される必要がある。  
もし後者の方法を利用していたら引数を増やしたくなった時、 その関数を使っているすべてのファイルの宣言部分を変更して回らなければいけなくなり、結局コンパイルしなおされるcppファイルの数はヘッダーファイルを用いたときと変わらない上に面倒が多くコンパイルエラーの嵐となる恐れがある。  

ではなぜ後者の方法を紹介したのか、疑問に思うかもしれない。  
その理由については後でクラスのファイル分けをする時によくわかるだろう。  

# グローバル変数のファイル分け

グローバル変数は関数と違って定義が一行で済む上、いくつかの変数間で相関があったりするのでできれば少数のファイルで一括して管理したい。  
もちろん、関数のときと同様に変数ごとにヘッダーファイルを用意することもできるが、一行のためにファイルを分けるのは非常にバカバカしい。  
かといって一つのヘッダーファイルですべて宣言した場合、小規模ゲームでは全く問題はないが、大規模になってくるとグローバル変数を追加したり削除したりするだけで多くのファイルがコンパイルしなおしになってしまう。  
結論としてはここで紹介する方法は、グローバル変数の定義を管理するcppファイルを作成し、新たなグローバル変数が必要になったときは必要となった場所(基本的にcppファイル)で宣言して使用し、最初の定義を管理するcppファイルに定義を追加するといったものである。  

理由は後回しにして先に具体例を見ていこう。  
次のコードをファイル分けする。  

```cpp
/* Main.cpp */
#include<iostream>

const int gWindowSizeX = 600;
const int gWindowSizeY = 480;

int main() {
    // ウィンドウサイズを利用した処理
}
```

このグローバル変数部分を別ファイルで定義する。  

```cpp
/* MyGlobal.cpp */
const int gWindowSizeX = 600;
const int gWindowSizeY = 480;
```

```cpp
/* Main.cpp */
#include<iostream>

extern const int gWindowSizeX;
extern const int gWindowSizeY;

int main() {
    // ウィンドウサイズを利用した処理
}
```

関数と違い、変数の宣言に必要なものは型情報と変数名だけである。  
関数の時に言い忘れたがVisualStudioの便利な機能で、変数を選択してCtrlを押しながら二回Rを押すことでプロジェクト内の変数名や関数名を一括して変更できる。  
そのため、変数名を変更する分にはヘッダーファイルを作らなくても問題はなさそうだ。  

では型を変更したくなったらどうするだろう。  
例えばウィンドウサイズをint型で管理していたが、ディスプレイの画素数に革命が起きてlong型が必要になってしまったとする。(まぁまずありえないが)  
このとき、変数の宣言した個所をすべて回って変更する必要が出てきてしまう。  
それが少数なら大きな問題ではないが、ウィンドウサイズのように多くの場面で使われる可能性のあるものに関しては大問題である。  
一番確実な方法としてその変数専用の型を作ってしまうものがある。  
リファレンスなどでstd::size_t型のものを見たことがある人もいるだろう。  
このように頻繁に使われる可能性のあるグローバル変数は専用の型を作ってしまえば万が一型を変更することになってもすぐに対応できる。  

この講座のおまけの回で時間を管理するクラスを作成する。  
時間の管理はフレーム数で行う方法と、時間の経過を計測して行う方法と大きく二種類あり、それを変更するのにクラスを作成しておくと楽だからである。  
これをunsigned型などで管理してしまうとすべて書き換えになってしまうので非常に手間だ。  
最初にすべての仕様を決定できるわけではないので迷ったらクラスを作ってしまうという方法も覚えておくといいだろう。  

# クラスのファイル分け

クラスは関数やグローバル変数と違ってcppファイルをまたいでいれば何度も定義を書いてもいい。(実際そうしないと使いようがない)  

この時問題となるのが定義文すべての内容が一致している必要があるということだ。  
これは至極当然なことで、cppファイルによって同じクラスなのに中身が違うなんてことが起きたら大変だ。  
クラスの中身が変更されることがよくあるので、クラスの定義はヘッダーファイルに書いて使うところでインクルードして同じ内容を共有するのがいいだろう。  

さて、このヘッダーファイルをどこでインクルードしようか。  
使うところすべてでインクルードすればもちろん問題なく動作する。  

```cpp
/* A.h */
#pragma once
class A {
    //...
};
```
```cpp
/* B.h */
#pragma once
#include"A.h"
class B {
public:
    A a;
};
```
```cpp
/* C.h */
#pragma once
#include"B.h"
class C {
public:
    B b;
}
```

この時問題となるのがA.hの中身を変更した時のコンパイルの問題である。  
class Bが持つメンバ関数等の定義を書いたB.cppがあるとして、BはAを利用しているのでB.cppのコンパイルしなおしは間違いなく必要である。  
ではclass Cを利用しているcppファイルはどうだろうか。  
せっかくBの中に閉じ込めて直接的な変更はされていなくてもこのままではコンパイルしなおしになってしまう。  

誤解を恐れずに例を挙げる。  
パンを作る工場で、パンが入った箱と包装紙から梱包を行う機械(class C)があったとする。  
そのパンの種類が変わったとき(A.hの中身が変更されたとき)、当然パンを箱に詰める機械(class B)も多少の調整(コンパイルしなおし)が必要だろう。  
一方で、梱包する機械(class C)はそのまま利用できるように思う。  
しかし最初に紹介した方法だと梱包する機械(class C)も作り直し(コンパイルしなおし)になってしまうのだ。  

A, B, Cのクラスがこのような関係になっているとき、この問題を解決できる手段がある。  

B.hを
```cpp
/* B.h */
#pragma once
class A;
class B {
public:
    A *a;
};
```

に変更する。  
クラスのメンバに他のクラスを持たせるとき、実体が必ず必要な場合はほとんどなくポインタで十分である。  
クラスの宣言のみの場合、ポインタは利用できるのでこのようなことができるのである。  

こうすると、class Bのメンバ関数等の定義を行うファイルではA.hをインクルードする必要があるが、class CのcppファイルではBを介さずに直接Aを用いることをしなければA.hをインクルードする必要はなく無事コンパイル時間を短縮できた。  

たかだか3つのファイル程度であれば気にするほどの問題ではないが、そのヘッダーファイルを起点にいくつものファイルを作っていたときに少し変更を加えただけでいくつものファイルがコンパイルしなおしになるのは非常に無駄である。  
いうなれば、一つの商品のパンの種類を変更しただけで工場全体が建て直しになるようなものである。  

# コンポジションとunique_ptr

上の例で問題となるのが実体の管理である。  

class Bの中のclass A型のポインタ変数aの指す先はどうなっているだろうか。  
Bのコンストラクタでnewしてそのポインタを渡していたらもちろんちゃんと動作する。  
このとき、いつdeleteするのかが問題となる。  
Bのデストラクタで開放処理を書いてもいいが、やや面倒な上開放し忘れにも気づきにくい。(コピー発生時にも面倒なことが起こる)  

そこでスマートポインタを用いる。(C++の補完/08_unique_ptr 参照)  
unique_ptrの宣言の時にはクラスの宣言があればできるので
```cpp
/* B.h */
#pragma once
#include<memory>

class A;ｓ
class B {
public:
    B();
    std::unique_ptr<A> a;
}
```
```cpp
/* B.cpp */
#include"A.h"

B::B() : 
    a(make_unique<A>())
{
}
```

こうすることでaの指し示す先がclass Bのインスタンスと運命共同体になり、コンポジションが実現できたように思う。  

しかし、スマートポインタを使ったときのファイル分けはポインタを使ったときとやや異なる点がある。  
make_uniqueしたとき、指定したクラスのメンバにunique_ptr<Hoge>型のものがあったとするとHogeクラスの定義も必要ということだ。  
さっきのA, B, Cに例えると、
```cpp
/* A.h */
#pragma once
class A {
    //...
};
```
```cpp
/* B.h */
#pragma once
#include<memory>
class A;
class B {
public:
    B();
    std::unique_ptr<A> a;
};
```
```cpp
/* B.cpp */
#include"A.h"
#include"B.h"
B::B() : 
    a(std::make_unique<A>())
{}
```
```cpp
/* C.h */
#pragma once
#include<memory>
class B;
class C {
public:
    C();
    std::unique_ptr<B> b;
};
```
```cpp
/* C.cpp */
#include"A.h" //←これがないとコンパイルエラー
#include"B.h"
#include"C.h"
C::C() : 
    b(std::make_unique<B>())
{}
```

これではせっかくコンパイル時間を短縮しようと思ったのにあまり意味がない。  
そのため、ポインタの管理が問題になりそうな場合を除いてコピーを禁止した上でコンストラクタとデストラクタで実態を生成破棄する。  

一方、public継承を用いたポリモーフィズムをunique_ptrでやろうとする場合は基底クラスのヘッダーだけManagerクラスのヘッダーと一緒にインクルードすればManagerクラスのインスタンスを生成できる。  
vector等のコンテナから要素を削除するときにdeleteし忘れが起こりがちなので今回はポリモーフィズムの場面ではunique_ptrを使うことにする。  

# 具体例

class Aなど抽象化して話していたので、具体的に敵を管理するクラスEnemyを例に紹介する。  

まず、敵の具体的な挙動を書くEnemyクラスを作る。  

```cpp
/* EnemyBase.h */
#pragma once
class EnemyBase {
protected:
    EnemyBase() {}
public:
    virtual void update() {}
    virtual void draw() const {}
    virtual ~EnemyBase() = default;
};
```
```cpp
/* Enemy.h */
#include"EnemyBase.h"
class Enemy : public EnemyBase {
public:
    Enemy(float x, float y);
    virtual void update() override;
    virtual void draw() const override;
    virtual ~Enemy() = default;
private:
    float x, y;
};
```
```cpp
/* Enemy.cpp */
#include"DxLib.h"
#include"Enemy.h"

Enemy::Enemy(float x, float y) : 
    x(x), y(y)
{}

void Enemy::update() {
    y++;
}

void Enemy::draw() const {
    DrawCircle(x, y, 30, GetColor(255, 0, 0));
}
```

Enemyを管理するEnemyManagerクラスを作る。  
このとき、ヘッダーファイルでEnemyBase.hをインクルードしない。  

```cpp
/* EnemyManager.h */
#pragma once
#include<vector>
#include<memory>
//#include"EnemyBase.h"
//↑こうしない
class EnemyBase;
class EnemyManager {
public:
    EnemyManager();
    void update();
    void draw() const;
private:
    std::vector<std::unique_ptr<EnemyBase>> mEnemy;
};
```
```cpp
/* EnemyManager.cpp */
#include"EnemyManager.h"
#include"Enemy.h"
//↑ここではEnemyのなかみが必要なのでインクルードする

EnemyManager::EnemyManager()
    mEnemy(std::make_unique<Enemy>(1.0f, 2.0f))
{
}

void EnemyManager::update() {
    for(auto &i : mEnemy) {
        mEnemy->update();
    }
}

void EnemyManager::draw() const {
    for(const auto &i : mEnemy) {
        mEnemy->draw();
    }
}
```

敵やプレイヤーなどゲーム中に必要なものを管理するGameManagerクラスでEnemyManagerを管理する。  
PlayerクラスはEnemyみたいなものがあると仮定する。  

```cpp
/* GameManager.h */
#pragma once
#include<memory>
class EnemyManager;
class Player;
class GameManager {
public:
    GameManager();
    GameManager(const GameManager &) = delete; //コピー禁止
    GameManager &operator=(GameManager &) = delete; //コピー禁止
    ~GameManager();
    void update();
private:
    EnemyManager *mEnemyManager;
    Player *mPlayer;
};
```

```cpp
/* GameManager.cpp */
#include"GameManager.h"
#include"EnemyManager.h"
#include"Player.h"

GameManager::GameManager() : 
    mEnemyManager(new EnemyManager()),
    mPlayer(new Player())
{
}

GameManager::~GameManager {
    delete mEnemyManager;
    delete mPlayer;
}

void GameManager::update() {
    mEnemyManager->update();
    mPlayer->update();
    mEnemyManager->draw();
    mPlayer->draw();
}
```

こうすることで、Enemy.hの中身を変更してもGameManager.cppはコンパイルしなおしにならず、GameManagerを使う別のクラスも影響を受けないためコンパイル時間を短縮できる。  

# まとめ

関数、グローバル変数、クラスのファイル分けの方法をコンパイル時間を最小限に抑えるという目的に沿って紹介した。  
コンパイル時間の観点に立つとヘッダーファイルの中身はできるだけ変更したくない。  
この後はできるだけヘッダーファイルの中身を変更しない工夫が随所にちりばめられている。  
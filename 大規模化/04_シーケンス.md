## ゲーム制作講座
***
前回示したシーン遷移ではすべてのシーンのインスタンスを最初に作ってしまっていたことからコンストラクタのほかにinit関数を用意する必要があった。  
また、すべてのインスタンスを最初に生成してしまうことは規模が大きくなっていったときにメモリが必要以上に占有されてしまって場合によっては要求マシンスペックが必要以上に上がってしまう。  
「自分で作ったものは自分で破棄する」を合言葉に解決方法を紹介する。  
この回を見るにあたってこれまでのシーン遷移の方法を確認しておいてもらいたい。  

# mScene

これまで、各シーンのインスタンスを配列で管理してきた。  
```cpp
std::array<std::unique_ptr<Scene::Base>, Scene::Manager::GAMEMODE_SIZE> Scene::Manager::mScene;
```
しかし実際にupdate関数が呼ばれるのはその中の一つの要素だけである。  
```cpp
void Scene::Manager::update() {
    mScene[mGameMode]->update();
}
```
実際に呼ばれるのが一つであるならそれだけを保持すれば十分である。  
配列で管理するのをやめて一つのScene::Base型のunique_ptrを持つように変更する。  
```cpp
std::unique_ptr<Scene::Base> Scene::Manager::mScene;
```
このとき問題になるのがどう遷移させるか、という問題である。  
配列で管理していれば[]に渡す値を変更すればよかったが、今はそういうわけにはいかない。  
この解決方法を2つ紹介する。  

# enumを諦めない

Scene::Manager::changeScene関数の中でもらってきたGameMode型の値に応じて次のシーンのインスタンスを生成してmSceneをresetするというものがある。  
```cpp
void Scene::Manager::changeScene(const GameMode &next) {
    switch(next) {
    case GAMEMODE_TITLE:
        mScene.reset(std::make_unique<Scene::Title::Manager>());
    case GAMEMODE_GAME:
        mScene.reset(std::make_unique<Scene::Game::Manager>());
    //...
    }
}
```

この場合の問題点としてはやりenumをあからさまに用いていることがあげられる。  
各シーン側からGameMode型のものを呼ぶわけだが、シーンが一つ追加されるたびにこの型が定義されているヘッダーファイルが変更され、すべてのシーンがコンパイルし直しになってしまう。  

各シーンにint型やsize_t型のstaticメンバを持たせてどこかのcppファイルでenumを定義しキャストしたものを渡すということをすればGameMode型をあからさまに用いることなくchangeScene関数を呼ぶことができる。  
そのとき名前なし名前空間を用いることで名前の衝突を減らすことができる。  

```cpp
/* Title/Manager.h */
#pragma once
namespace Scene { namespace Title {
    class Manager {
    public:
        static const int GameMode_this;
        static const int GameMode_game;
    };
}}
```

```cpp
/* GameMode.cpp */
#include"./Manager.h" //SceneManager
#include"./Title/Manager.h"

namespace {
    enum GameMode {
        GAMEMODE_TITLE,
        GAMEMODE_GAME,
        //...
        GAMEMODE_SIZE
    };
}

namespace Scene {
    namespace Title {
        const int Manager::GameMode_this = GAMEMODE_TITLE;
        const int Manager::GameMode_game = GAMEMODE_GAME;
    }
    //...
}
```

```cpp
/* Manager.cpp */
//↑SceneのManager

//...

void Scene::Manager::changeScene(const int &next) {
    switch(next) {
    case Scene::Title::Manager::GameMode_this:
        mScene.reset(std::make_unique<Scene::Title::Manager>());
    case Scene::Game::Manager::GameMode_this:
        mScene.reset(std::make_unique<Scene::Game::Manager>());
    //...
    }
}
```

問題点としては各シーンのヘッダーファイルを書き換えたときSceneのManager.cppとGameMode.cppの2つのファイルが追加でリコンパイルされることである。  
前よりはずいぶん変更に強くなったといえるだろう。  

staticなメンバが増えたことでメモリ効率を気にする人がいるかもしれない。  
今回は各シーンクラスにそれぞれ自分と遷移先の情報が入ったint型の変数なので1つあたり8バイトから10数バイト程度である。  
1000個シーンを作ったとして10数キロバイトになる。  
これを重いとみるか否かでこの方法の有効性が変わってくる。  
実際のところ次を見てもらうとわかるが、メモリ効率から見たこの方法の有効性を議論する以前にもっといい方法がある。  
enumが有効に働くとき、このような方法をとることがあるかもしれないので何となく覚えておいていいことがあるかもしれない。  

# enumを捨てよう

今回そこまでしてenumを使う理由があるかと言われれば「「「ない」」」と断言できる。  
実際のところ、順番通りに並んでいるというenumの特徴が全く生かされていない。  
被りなく値を振り分けるという特徴を使ってはいるものの、public継承を用いたポリモーフィズムではそれぞれを見分けることができるように作られているため必要ない。  
今後enumを使うときはおそらく優先順位をつけたいときくらいだろう。  

ではenumを使わないでどうやってシーンを遷移するのか考えよう。  
シーンを切り替えるには次のシーンのインスタンスを生成してそのポインタをmSceneのreset関数に渡す必要がある。  
次のシーンのインスタンスをScene::Managerで作成していたためenumの必要性が発生してしまっていた。  
それを各シーンの中で行えばenumから解放されるだろう。  
実際に必要なのは次のシーンのインスタンスそのものではなくそのポインタであり、それをScene::Baseにアップキャストした後でも問題ない。  
各シーンからそれを受け取るにはupdate関数の返り値をScene::Base*にして次のシーンのポインタを返してもらえば遷移するのに必要なものはそろった。  

あとは遷移するかしないかの判定をどうするかという問題である。  
特定のポインタというものはnullptrしかないので遷移しないときはnullptrを返してきてもいいが、nullptrは例外処理の時に使いたいという事情がある。  
ほかにScene::Managerからも各シーンからも知ることができるScene::Baseのポインタとして、今実行中のシーンのポインタというものがある。  
Scene::Managerは最初に持っているものであり、各シーンからはthisポインタからアクセスできる。  
つまり、シーンを遷移しないときはthisポインタを返し、遷移するときは遷移先のインスタンスを生成してそのポインタを返すようにすることでシーン遷移を実現できる。  

コードにしていこう。  

まず、Scene::Baseのupdate関数の返り値を変更する。  
```cpp
/* Scene/Base.h */
#pragma once

namespace Scene {
    class Base {
    protected:
        Base() {}
    public:
        virtual Scene::Base *update() {}
    };
}
```

これに伴ってTitleやGameのManagerクラスのupdate関数の返り値もScene::Base型に変更する。  

次に、各シーンのupdate関数の返り値を書き込んでいく。  
今のところゲームは終わらせていないのでGame::Manager::updateの返り値は常にthisでいい。  
Titleの方のupdate関数だが、スペースキーを離したときにGameに移るようになっている。  
これを、スペースキーが離されたらGameのインスタンスをmake_uniqueしてそのポインタをreleaseさせて返す。  
今回の場合、例外にはあたらないのでnewしてしまってもいいだろう。  
間違ってget関数にしてしまった場合そのポインタは無効になってしまうので注意が必要だ。  
また、今回Titleの方でGameが必要なのでインクルードしよう。  

さて、こうして各シーンの方で変更を終えたところでScene::Managerの方も変更を加える。  
まずchangeScene関数とenum、mGameModeは不要になったので削除する。  
次にmSceneが配列になっていたので単一のポインタを持つunique_ptrに変更する。   
これにイニシャライザでTitleのインスタンスをmake_uniqueして入れる。  
このとき、Scene::ManagerからGameを直接扱うことはなくなったのでインクルードしていたものは削除する。  

最後に、Scene::Manager::updateの中身を
```cpp
Base *p = mScene->update();
if (p != mScene.get()) mScene.reset(p);
```
とする。  
返ってきたポインタが今のものと同じならそのまま、違ったらresetするということが書かれている。  

こうしてenumを使わずにシーン遷移ができた。  

# まとめ
今回シーケンスという表題にしながら普通にシーン遷移をとりあつかった。  
内容としてはenumを残しながら変更に強くする工夫を紹介したあと、enumを使わないものを紹介した。  
シーケンスというのはこの講座のなかではシーンを取りまとめたものをいう。  
次回、Stateクラスを作成し階層化することでシーケンスとして扱う。  
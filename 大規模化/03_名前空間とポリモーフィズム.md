## ゲーム制作講座
***
名前空間を利用する例としてポリモーフィズムを考える。  
C++の補完/07_名前空間 参照
ポリモーフィズムに必要な要素は決まり切っているため、名前空間を分けやすい。  

# public継承を用いたポリモーフィズム

今更説明するまでもないが、簡単に確認しておく。  

public継承の関係にある二つのクラスBase, Derivedを考える。  
```cpp
class Base {
}
class Derived : public Base {
};
```

このとき、Base*のポインタ変数にDerivedのインスタンスのポインタを入れることができる。(アップキャストという)  
```cpp
Base *p = new Derived();
```
これを利用して、Baseを継承した複数のクラスをBase*の配列等でまとめて扱うことができる。  

また、メンバ関数を基底クラスの方でvirtualをつけて派生クラスの方でoverrideすることで内容を書き換えることができ、基底クラスのポインタからオーバーライドした派生クラスのメンバ関数を呼び出すことができる。  
```cpp
class Base {
public:
    virtual void f();
};
class Derived : public Base {
public:
    virtual void f() override;
};

int main() {
    Base *p = new Derived();
    p->f(); //Derivedクラスのf関数が呼ばれる
}
```

様々な派生クラスのポインタを管理するためにManagerクラスを作る。  
```cpp
class Base;
class Manager {
public:
    std::vector<Base*> vec;
};
```

基本的にこのManagerクラスを通して各派生クラスの管理を行う。  

# 名前空間の導入

ポリモーフィズムは大抵の場合この形になる。  
```cpp
class Base;
class Manager;
class Derived1;
class Derived2;
```
そのため、これらをまとめて一つの名前空間に入れてしまうときれいに整理される。  

前回紹介したEnemyまわりをEnemy名前空間に入れてしまおう。  

```cpp
namespace Enemy {
    class Base {
    };
    class Manager {
    private:
        std::vector<std::unique_ptr<Base>> mEnemy;
    };
    class A : public Base {
    };
}
```

あとはここにEnemy::Baseを継承したクラスを作成していき、必要になったらManagerのmEnemyに新しいインスタンスのポインタをmake_uniqueして追加していくことで活用できる。  

# ファイル分け

名前空間が絡んだファイル分けをまだ行っていなかったのでEnemyを例に紹介する。  

Enemy名前空間にBaseクラスとManagerクラスを作成する。  

```cpp
/* Base.h */
#pragma once

namespace Enemy {
    class Base {
    protected:
        Base();
    public:
        virtual void update() {}
        virtual void draw() const {}
    };
}
```
```cpp
/* Manager.h */
#pragma once
#include<memory>
#include<vector>

namespace Enemy {
    class Base;
    class Manager {
    public:
        Manager();
        void update();
        void draw() const;
    private:
        std::vector<std::unique_ptr<Base>> mEnemy;
    };
}
```
```cpp
/* Manager.cpp */
#include"Manager.h"
#include"Base.h"

namespace Enemy {
    Manager::Manager() {

    }
    void Manager::update() {
        for(auto &i : mEnemy) {
            i->update();
        }
    }
    void Manager::draw() const {
        for(const auto &i : mEnemy) {
            i->draw()
        }
    }
}
```

普通に今までのファイル分けに加えてファイルの中身をnamespace Enemy{}で囲うだけである。  
cppファイルにおいては
```cpp
using namespace Enemy;
```
としてもいいだろう。
しかし次の回でシーケンス遷移を導入したりポリモーフィズムしている要素が増えたりすると、名前空間が違う同じ名前のクラスが増えてくるため、意図しているクラスと違うものが呼ばれてしまっていることもあるため注意が必要だ。  
Visual Studioの機能で、クラスにカーソルを合わせるとどの名前空間のものであるかをスコープ解決演算子を用いて表示してくれる。  
怪しい時は確認してみるといいだろう。  

# フォルダの利用

名前空間ごとにフォルダにまとめると便利だ。  

Enemyを例にとると、Enemy名前空間内に作成したクラスをファイル分けしたときファイル名がManager.hなどの他と被りやすい名前をしていた。  
他と名前が被ることを防ぐために名前空間を利用したのにファイル名を長くしてしまったら少しもったいない。  
そこでフォルダを利用する。  

Visual Studioの初期設定ではフォルダ分けしても同じ名前のファイルが存在しているとコンパイルができないため、おまけ/VisualStudioの設定を参考に設定を変更しておいてほしい。  

複数人でゲームを作る場合、ほかの人に書いてもらうものをフォルダにまとめられるので勝手にファイルを作ったりしても問題が生じにくい。  

# まとめ

継承を用いたポリモーフィズム全体を一つの名前空間に入れてしまうと管理しやすい。  
名前空間を用いるとクラス名が長ったらしくならずに比較的スッキリする。  
複数人でコードを書くときに名前空間とフォルダ分けはとても便利である。  